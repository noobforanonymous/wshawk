#!/usr/bin/env python3
"""
Tests for WSHawk Vulnerability Verifier
"""

import pytest
from wshawk.vulnerability_verifier import VulnerabilityVerifier, ConfidenceLevel


@pytest.fixture
def verifier():
    return VulnerabilityVerifier()


class TestSQLInjectionVerification:
    """SQL injection detection through error signatures"""

    def test_detects_mysql_error(self, verifier):
        response = 'Error: You have an error in your SQL syntax near "1=1"'
        is_vuln, conf, desc = verifier.verify_sql_injection(response, "' OR 1=1--")
        assert is_vuln is True

    def test_detects_postgres_error(self, verifier):
        response = "PostgreSQL query ERROR: unterminated quoted string at or near"
        is_vuln, conf, desc = verifier.verify_sql_injection(response, "' OR 1=1--")
        assert is_vuln is True

    def test_detects_mssql_error(self, verifier):
        response = "Unclosed quotation mark after the character string"
        is_vuln, conf, desc = verifier.verify_sql_injection(response, "' OR 1=1--")
        assert is_vuln is True

    def test_no_false_positive_on_clean_response(self, verifier):
        response = '{"status": "ok", "data": [1, 2, 3]}'
        is_vuln, conf, desc = verifier.verify_sql_injection(response, "' OR 1=1--")
        assert is_vuln is False

    def test_no_false_positive_on_normal_error(self, verifier):
        response = '{"error": "Invalid input", "code": 400}'
        is_vuln, conf, desc = verifier.verify_sql_injection(response, "test")
        assert is_vuln is False


class TestXSSVerification:
    """XSS detection through context analysis"""

    def test_detects_reflected_script_tag(self, verifier):
        payload = "<script>alert(1)</script>"
        response = f'<div>{payload}</div>'
        is_vuln, conf, desc = verifier.verify_xss(response, payload)
        assert is_vuln is True

    def test_detects_event_handler(self, verifier):
        payload = '<img src=x onerror=alert(1)>'
        response = f'<div>{payload}</div>'
        is_vuln, conf, desc = verifier.verify_xss(response, payload)
        assert is_vuln is True

    def test_no_false_positive_on_encoded_output(self, verifier):
        payload = "<script>alert(1)</script>"
        response = "&lt;script&gt;alert(1)&lt;/script&gt;"
        is_vuln, conf, desc = verifier.verify_xss(response, payload)
        assert is_vuln is False

    def test_no_false_positive_on_clean_response(self, verifier):
        response = '{"message": "Hello World"}'
        is_vuln, conf, desc = verifier.verify_xss(response, "<script>alert(1)</script>")
        assert is_vuln is False


class TestCommandInjectionVerification:
    """Command injection detection through error patterns"""

    def test_detects_shell_error(self, verifier):
        response = "/bin/sh: 1: command not found"
        is_vuln, conf, desc = verifier.verify_command_injection(response, "; ls")
        assert is_vuln is True

    def test_no_false_positive_on_clean(self, verifier):
        response = '{"status": "ok"}'
        is_vuln, conf, desc = verifier.verify_command_injection(response, "; ls")
        assert is_vuln is False


class TestPathTraversalVerification:
    """Path traversal detection through file content"""

    def test_detects_etc_passwd(self, verifier):
        response = "root:x:0:0:root:/root:/bin/bash\ndaemon:x:1:1:daemon:/usr/sbin"
        is_vuln, conf, desc = verifier.verify_path_traversal(response, "../../etc/passwd")
        assert is_vuln is True

    def test_detects_windows_ini(self, verifier):
        response = "[boot loader]\ntimeout=30\ndefault=multi(0)"
        is_vuln, conf, desc = verifier.verify_path_traversal(response, "..\\..\\boot.ini")
        assert is_vuln is True

    def test_no_false_positive_on_clean(self, verifier):
        response = '{"file": "readme.txt", "content": "Hello"}'
        is_vuln, conf, desc = verifier.verify_path_traversal(response, "../../etc/passwd")
        assert is_vuln is False


class TestStackTraceDetection:
    """Stack trace detection in responses"""

    def test_detects_python_traceback(self, verifier):
        response = 'Traceback (most recent call last):\n  File "app.py", line 42'
        is_detected, desc = verifier.detect_stack_trace(response)
        assert is_detected is True

    def test_detects_java_stacktrace(self, verifier):
        response = "java.lang.NullPointerException\n\tat com.app.Main.run(Main.java:15)"
        is_detected, desc = verifier.detect_stack_trace(response)
        assert is_detected is True

    def test_no_false_positive_on_clean(self, verifier):
        response = '{"message": "Everything is fine"}'
        is_detected, desc = verifier.detect_stack_trace(response)
        assert is_detected is False


class TestConfidenceCalculation:
    """Confidence levels should be properly calculated"""

    def test_confidence_returns_valid_level(self, verifier):
        analysis = {
            "payload_reflected": True,
            "error_detected": True,
            "stack_trace": False,
        }
        level = verifier.calculate_confidence(analysis, "SQL Injection")
        assert level in [
            ConfidenceLevel.LOW, ConfidenceLevel.MEDIUM,
            ConfidenceLevel.HIGH, ConfidenceLevel.CRITICAL,
        ]


class TestResponseContextAnalysis:
    """Comprehensive response analysis"""

    def test_analyze_json_response(self, verifier):
        response = '{"error": "invalid input", "payload": "<script>"}'
        result = verifier.analyze_response_context(response, "<script>")
        assert isinstance(result, dict)

    def test_analyze_html_response(self, verifier):
        response = "<html><body><div>test</div></body></html>"
        result = verifier.analyze_response_context(response, "test")
        assert isinstance(result, dict)
