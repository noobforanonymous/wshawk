"""
WSHawk Subdomain Finder Engine
Enumerates subdomains using passive sources (crt.sh, AlienVault OTX)
and optional active DNS brute-forcing with resolution validation.
"""

import aiohttp
import asyncio
import socket
from typing import List, Set


class WSHawkSubdomainFinder:
    """
    Multi-source subdomain enumeration engine.

    Sources:
        - crt.sh (Certificate Transparency logs)
        - AlienVault OTX (Passive DNS)
        - Active brute-force with common subdomain prefixes (optional)
        - DNS resolution validation to filter dead hosts (optional)
    """

    # Common subdomain prefixes for active brute-forcing
    BRUTE_PREFIXES = [
        "www", "mail", "dev", "test", "stage", "staging", "api", "admin",
        "vpn", "remote", "blog", "shop", "portal", "support", "help",
        "beta", "app", "cdn", "ns1", "ns2", "ftp", "webmail", "smtp",
        "pop", "imap", "m", "mobile", "docs", "wiki", "git", "ci",
    ]

    def __init__(self, sio_instance=None):
        self.sio = sio_instance

    async def list_subdomains(
        self,
        target: str,
        active_brute: bool = False,
        active_resolve: bool = True,
    ) -> List[str]:
        """
        Enumerate subdomains for a target domain.

        Args:
            target:         Domain to enumerate (e.g. 'example.com').
            active_brute:   If True, also try common subdomain prefixes.
            active_resolve: If True, validate subdomains via DNS resolution.

        Returns:
            Sorted list of discovered subdomain hostnames.

        Raises:
            ValueError: If target domain is empty.
        """
        # ── Sanitize input ──
        target = (
            target.replace("https://", "")
            .replace("http://", "")
            .split("/")[0]
            .strip()
            .lower()
        )
        if not target or "." not in target:
            raise ValueError("Valid target domain required (e.g. example.com)")

        subs: Set[str] = set()

        # ── Passive gathering (concurrent) ──
        crt_task = self._query_crt_sh(target)
        otx_task = self._query_alienvault(target)
        crt_results, otx_results = await asyncio.gather(
            crt_task, otx_task, return_exceptions=True
        )

        if isinstance(crt_results, set):
            subs.update(crt_results)
        if isinstance(otx_results, set):
            subs.update(otx_results)

        # ── Active brute-force (optional) ──
        if active_brute:
            for prefix in self.BRUTE_PREFIXES:
                subs.add(f"{prefix}.{target}")

        # ── DNS resolution filter (optional) ──
        if active_resolve and subs:
            subs = await self._resolve_hosts(subs)

        return sorted(list(subs))

    async def _query_crt_sh(self, domain: str) -> Set[str]:
        """Query crt.sh Certificate Transparency logs."""
        results: Set[str] = set()
        try:
            url = f"https://crt.sh/?q=%25.{domain}&output=json"
            timeout = aiohttp.ClientTimeout(total=15)
            async with aiohttp.ClientSession() as session:
                async with session.get(url, timeout=timeout) as resp:
                    if resp.status == 200:
                        data = await resp.json()
                        for item in data:
                            for name in item.get("name_value", "").split("\n"):
                                name = name.strip().lower()
                                if name.endswith(domain) and not name.startswith("*"):
                                    results.add(name)
        except Exception:
            pass  # crt.sh can be flaky — fail silently
        return results

    async def _query_alienvault(self, domain: str) -> Set[str]:
        """Query AlienVault OTX passive DNS API."""
        results: Set[str] = set()
        try:
            url = f"https://otx.alienvault.com/api/v1/indicators/domain/{domain}/passive_dns"
            timeout = aiohttp.ClientTimeout(total=10)
            async with aiohttp.ClientSession() as session:
                async with session.get(url, timeout=timeout) as resp:
                    if resp.status == 200:
                        data = await resp.json()
                        for entry in data.get("passive_dns", []):
                            host = entry.get("hostname", "").lower()
                            if host.endswith(domain) and not host.startswith("*"):
                                results.add(host)
        except Exception:
            pass
        return results

    async def _resolve_hosts(self, hostnames: Set[str]) -> Set[str]:
        """Validate hostnames via DNS resolution, filtering out dead ones."""
        valid: Set[str] = set()
        sem = asyncio.Semaphore(50)

        async def _check(hostname: str):
            async with sem:
                try:
                    await asyncio.to_thread(socket.gethostbyname, hostname)
                    valid.add(hostname)
                except (socket.gaierror, OSError):
                    pass  # Host doesn't resolve — skip it

        await asyncio.gather(*[_check(h) for h in hostnames])
        return valid
