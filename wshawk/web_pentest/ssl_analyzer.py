"""
WSHawk SSL/TLS Analyzer
Checks certificate details, expiry, issuer, protocol support, and cipher strength.
Uses Python's built-in ssl module for deep inspection.
"""

import ssl
import socket
import asyncio
from datetime import datetime
from typing import Dict, Any, List


class WSHawkSSLAnalyzer:
    """Inspects SSL/TLS configuration of a target host."""

    def __init__(self):
        pass

    async def analyze(self, host: str, port: int = 443) -> Dict[str, Any]:
        """
        Perform SSL/TLS analysis on a given host.

        Returns certificate details, expiry info, protocol support, and risk assessment.
        """
        host = host.replace("https://", "").replace("http://", "").split("/")[0]
        if ":" in host:
            parts = host.split(":")
            host = parts[0]
            port = int(parts[1])

        result = {
            "host": host,
            "port": port,
            "certificate": {},
            "protocols": [],
            "risk_score": "Safe",
            "issues": []
        }

        # Run blocking SSL ops in thread pool
        cert_info = await asyncio.to_thread(self._get_cert_info, host, port)
        result["certificate"] = cert_info.get("cert", {})
        result["issues"] = cert_info.get("issues", [])

        # Check protocol support
        protocols = await asyncio.to_thread(self._check_protocols, host, port)
        result["protocols"] = protocols

        # Check for weak protocols
        for p in protocols:
            if p["supported"] and p["name"] in ("SSLv3", "TLSv1.0", "TLSv1.1"):
                result["issues"].append({
                    "severity": "High",
                    "msg": f"Weak protocol {p['name']} is supported"
                })

        # Overall risk
        high_count = sum(1 for i in result["issues"] if i.get("severity") == "High")
        med_count = sum(1 for i in result["issues"] if i.get("severity") == "Medium")

        if high_count > 0:
            result["risk_score"] = "High"
        elif med_count > 0:
            result["risk_score"] = "Medium"
        else:
            result["risk_score"] = "Safe"

        return result

    def _get_cert_info(self, host: str, port: int) -> Dict:
        """Extract certificate details from the target."""
        issues = []
        cert_data = {}

        try:
            ctx = ssl.create_default_context()
            ctx.check_hostname = False
            ctx.verify_mode = ssl.CERT_NONE

            with socket.create_connection((host, port), timeout=8) as sock:
                with ctx.wrap_socket(sock, server_hostname=host) as ssock:
                    # Get binary DER cert
                    der_cert = ssock.getpeercert(binary_form=True)
                    # Get parsed cert (only works with CERT_REQUIRED, so we make another connection)
                    cipher = ssock.cipher()
                    protocol = ssock.version()

            # Now get the actual parsed cert with verification
            try:
                ctx2 = ssl.create_default_context()
                with socket.create_connection((host, port), timeout=8) as sock2:
                    with ctx2.wrap_socket(sock2, server_hostname=host) as ssock2:
                        cert = ssock2.getpeercert()
            except ssl.SSLCertVerificationError as e:
                cert = {}
                issues.append({"severity": "High", "msg": f"Certificate verification failed: {str(e)}"})
            except Exception:
                cert = {}

            # Parse cert fields
            subject = dict(x[0] for x in cert.get("subject", ()) if x)
            issuer = dict(x[0] for x in cert.get("issuer", ()) if x)

            not_before = cert.get("notBefore", "")
            not_after = cert.get("notAfter", "")

            # Check expiry
            days_left = None
            if not_after:
                try:
                    expiry_dt = datetime.strptime(not_after, "%b %d %H:%M:%S %Y %Z")
                    days_left = (expiry_dt - datetime.utcnow()).days
                    if days_left < 0:
                        issues.append({"severity": "High", "msg": f"Certificate EXPIRED {abs(days_left)} days ago"})
                    elif days_left < 30:
                        issues.append({"severity": "Medium", "msg": f"Certificate expires in {days_left} days"})
                except Exception:
                    pass

            # Check cipher strength
            if cipher:
                cipher_name = cipher[0]
                cipher_bits = cipher[2] if len(cipher) > 2 else 0
                if cipher_bits < 128:
                    issues.append({"severity": "High", "msg": f"Weak cipher: {cipher_name} ({cipher_bits}-bit)"})
            else:
                cipher_name = "Unknown"
                cipher_bits = 0

            # Check for self-signed
            if subject == issuer and subject:
                issues.append({"severity": "Medium", "msg": "Self-signed certificate detected"})

            cert_data = {
                "subject": subject.get("commonName", "Unknown"),
                "issuer": issuer.get("organizationName", issuer.get("commonName", "Unknown")),
                "not_before": not_before,
                "not_after": not_after,
                "days_remaining": days_left,
                "serial_number": cert.get("serialNumber", ""),
                "san": [entry[1] for entry in cert.get("subjectAltName", ())],
                "protocol": protocol,
                "cipher": cipher_name,
                "cipher_bits": cipher_bits
            }

        except Exception as e:
            issues.append({"severity": "High", "msg": f"SSL connection failed: {str(e)}"})

        return {"cert": cert_data, "issues": issues}

    def _check_protocols(self, host: str, port: int) -> List[Dict]:
        """Check which TLS/SSL protocol versions are supported."""
        protocols = []

        checks = [
            ("TLSv1.0", ssl.PROTOCOL_TLS),
            ("TLSv1.1", ssl.PROTOCOL_TLS),
            ("TLSv1.2", ssl.PROTOCOL_TLS),
            ("TLSv1.3", ssl.PROTOCOL_TLS),
        ]

        for name, _ in checks:
            supported = False
            try:
                ctx = ssl.SSLContext(ssl.PROTOCOL_TLS_CLIENT)
                ctx.check_hostname = False
                ctx.verify_mode = ssl.CERT_NONE

                # Set min/max protocol version
                if name == "TLSv1.0":
                    ctx.minimum_version = ssl.TLSVersion.TLSv1
                    ctx.maximum_version = ssl.TLSVersion.TLSv1
                elif name == "TLSv1.1":
                    ctx.minimum_version = ssl.TLSVersion.TLSv1_1
                    ctx.maximum_version = ssl.TLSVersion.TLSv1_1
                elif name == "TLSv1.2":
                    ctx.minimum_version = ssl.TLSVersion.TLSv1_2
                    ctx.maximum_version = ssl.TLSVersion.TLSv1_2
                elif name == "TLSv1.3":
                    ctx.minimum_version = ssl.TLSVersion.TLSv1_3
                    ctx.maximum_version = ssl.TLSVersion.TLSv1_3

                with socket.create_connection((host, port), timeout=5) as sock:
                    with ctx.wrap_socket(sock, server_hostname=host) as ssock:
                        supported = True
            except Exception:
                supported = False

            protocols.append({"name": name, "supported": supported})

        return protocols
