"""
WSHawk Attack Chainer Engine
Executes multi-step HTTP attack sequences where extracted values from one
response are automatically injected into subsequent requests. Supports
regex and CSS-like value extraction with variable templating.
"""

import asyncio
import aiohttp
import re
import time
import json
from typing import Dict, Any, List, Optional


class WSHawkAttackChainer:
    """
    Multi-step attack sequencer with value extraction and injection.

    Chains HTTP requests together by extracting values from responses
    (via regex patterns) and injecting them into subsequent requests.
    Useful for:
        - Session token harvesting and replay
        - Multi-step exploit chains
        - Authentication bypass sequences
        - Parameter mining from responses

    Features:
        - Ordered step execution with variable templating
        - Regex-based value extraction from response body/headers
        - Variable injection using {{var_name}} syntax
        - Conditional step execution (skip if variable missing)
        - Per-step response logging
        - Real-time Socket.IO progress updates
        - Cookie jar persistence across steps
    """

    def __init__(self, sio_instance=None):
        self.sio = sio_instance
        self.variables: Dict[str, str] = {}
        self.step_results: List[Dict] = []

    async def execute_chain(
        self, steps: List[Dict[str, Any]],
        initial_vars: Dict[str, str] = None,
    ) -> Dict[str, Any]:
        """
        Execute a sequence of chained HTTP requests.

        Each step can extract values from the response and inject
        previously extracted values into the request.

        Step format:
        {
            "name": "Step 1 â€” Get CSRF Token",
            "method": "GET",
            "url": "https://target.com/login",
            "headers": {"Accept": "text/html"},
            "body": "",
            "extract": [
                {
                    "var": "csrf_token",
                    "from": "body",          # "body", "headers", "cookies", "status"
                    "regex": 'name="csrf_token" value="([^"]+)"',
                }
            ],
            "condition": null,  # or "csrf_token" â€” skip if var doesn't exist
        }

        Variable injection uses {{var_name}} in url, headers, body.

        Args:
            steps: List of step definitions.
            initial_vars: Pre-set variables (e.g., from prior scans).

        Returns:
            Dict with 'results' for each step and final 'variables'.
        """
        if not steps or len(steps) == 0:
            raise ValueError("At least one step is required")

        start = time.time()
        self.variables = dict(initial_vars or {})
        self.step_results = []

        # Shared cookie jar across all steps
        jar = aiohttp.CookieJar(unsafe=True)

        async with aiohttp.ClientSession(cookie_jar=jar) as session:
            for i, step in enumerate(steps):
                step_name = step.get("name", f"Step {i + 1}")
                step_num = i + 1

                # Check condition
                condition = step.get("condition")
                if condition and condition not in self.variables:
                    result = {
                        "step": step_num,
                        "name": step_name,
                        "status": "skipped",
                        "reason": f"Variable '{condition}' not set",
                    }
                    self.step_results.append(result)

                    if self.sio:
                        await self.sio.emit("chain_step", result)
                    continue

                # Apply variable injection
                url = self._inject_vars(step.get("url", ""))
                method = step.get("method", "GET").upper()
                body = self._inject_vars(step.get("body", ""))
                raw_headers = step.get("headers", {})

                if isinstance(raw_headers, str):
                    raw_headers = self._parse_header_string(raw_headers)

                headers = {}
                for k, v in raw_headers.items():
                    headers[k] = self._inject_vars(str(v))

                # URL auto-prefix
                if url and not url.startswith(("http://", "https://")):
                    url = "https://" + url

                if not url:
                    result = {
                        "step": step_num,
                        "name": step_name,
                        "status": "error",
                        "reason": "URL is empty after variable injection",
                    }
                    self.step_results.append(result)
                    if self.sio:
                        await self.sio.emit("chain_step", result)
                    continue

                # Execute request
                try:
                    timeout = aiohttp.ClientTimeout(total=15)
                    async with session.request(
                        method, url,
                        data=body if body else None,
                        headers=headers,
                        ssl=False,
                        allow_redirects=False,
                        timeout=timeout,
                    ) as resp:
                        resp_body = await resp.text(errors='ignore')
                        resp_status = resp.status
                        resp_headers = dict(resp.headers)
                        resp_cookies = {
                            k: v.value for k, v in resp.cookies.items()
                        }

                except Exception as e:
                    result = {
                        "step": step_num,
                        "name": step_name,
                        "status": "error",
                        "reason": str(e),
                        "url": url,
                        "method": method,
                    }
                    self.step_results.append(result)
                    if self.sio:
                        await self.sio.emit("chain_step", result)
                    continue

                # Extract values
                extractions = step.get("extract", [])
                extracted = {}

                for ext in extractions:
                    var_name = ext.get("var", "")
                    source = ext.get("from", "body")
                    pattern = ext.get("regex", "")

                    if not var_name or not pattern:
                        continue

                    # Select source text
                    if source == "body":
                        search_text = resp_body
                    elif source == "headers":
                        search_text = "\n".join(
                            f"{k}: {v}" for k, v in resp_headers.items()
                        )
                    elif source == "cookies":
                        search_text = "\n".join(
                            f"{k}={v}" for k, v in resp_cookies.items()
                        )
                    elif source == "status":
                        search_text = str(resp_status)
                    else:
                        search_text = resp_body

                    # Run regex
                    try:
                        match = re.search(pattern, search_text, re.IGNORECASE)
                        if match:
                            value = match.group(1) if match.lastindex else match.group(0)
                            self.variables[var_name] = value
                            extracted[var_name] = value
                    except re.error as e:
                        extracted[var_name] = f"REGEX_ERROR: {str(e)}"

                result = {
                    "step": step_num,
                    "name": step_name,
                    "status": "success",
                    "http_status": resp_status,
                    "url": url,
                    "method": method,
                    "response_length": len(resp_body),
                    "extracted": extracted,
                    "response_preview": resp_body[:300],
                    "cookies_received": resp_cookies,
                }
                self.step_results.append(result)

                if self.sio:
                    await self.sio.emit("chain_step", result)

        elapsed = round(time.time() - start, 2)

        return {
            "results": self.step_results,
            "variables": self.variables,
            "total_steps": len(steps),
            "completed": sum(1 for r in self.step_results if r["status"] == "success"),
            "skipped": sum(1 for r in self.step_results if r["status"] == "skipped"),
            "errors": sum(1 for r in self.step_results if r["status"] == "error"),
            "elapsed": elapsed,
        }

    async def quick_extract(
        self, url: str, patterns: List[Dict[str, str]],
    ) -> Dict[str, Any]:
        """
        Quick single-request value extraction.

        Fetches a URL and extracts values using provided regex patterns.
        Useful for grabbing CSRF tokens, session IDs, API keys from a page.

        Args:
            url: Target URL to fetch.
            patterns: List of {"var": "name", "regex": "pattern", "from": "body"}.

        Returns:
            Dict with extracted variables and response metadata.
        """
        if not url:
            raise ValueError("URL required")

        url = url.strip()
        if not url.startswith(("http://", "https://")):
            url = "https://" + url

        start = time.time()

        try:
            timeout = aiohttp.ClientTimeout(total=10)
            async with aiohttp.ClientSession() as session:
                async with session.get(
                    url, ssl=False, allow_redirects=True, timeout=timeout
                ) as resp:
                    body = await resp.text(errors='ignore')
                    headers_str = "\n".join(
                        f"{k}: {v}" for k, v in resp.headers.items()
                    )
                    cookies_str = "\n".join(
                        f"{k}={v.value}" for k, v in resp.cookies.items()
                    )
                    status = resp.status
        except Exception as e:
            return {
                "url": url,
                "status": "error",
                "error": str(e),
                "extracted": {},
            }

        extracted = {}
        for p in patterns:
            var_name = p.get("var", "")
            regex = p.get("regex", "")
            source = p.get("from", "body")

            if not var_name or not regex:
                continue

            if source == "body":
                search_text = body
            elif source == "headers":
                search_text = headers_str
            elif source == "cookies":
                search_text = cookies_str
            else:
                search_text = body

            try:
                match = re.search(regex, search_text, re.IGNORECASE)
                if match:
                    value = match.group(1) if match.lastindex else match.group(0)
                    extracted[var_name] = value
            except re.error:
                extracted[var_name] = "REGEX_ERROR"

        elapsed = round(time.time() - start, 2)

        return {
            "url": url,
            "status": "success",
            "http_status": status,
            "extracted": extracted,
            "total_patterns": len(patterns),
            "matched": len(extracted),
            "elapsed": elapsed,
        }

    def _inject_vars(self, text: str) -> str:
        """Replace {{var_name}} placeholders with stored variable values."""
        if not text:
            return text

        def _replacer(match):
            var_name = match.group(1)
            return self.variables.get(var_name, match.group(0))

        return re.sub(r"\{\{(\w+)\}\}", _replacer, text)

    def _parse_header_string(self, headers_str: str) -> Dict[str, str]:
        """Parse 'Header: Value' per line into dict."""
        result = {}
        for line in headers_str.strip().splitlines():
            if ":" in line:
                k, v = line.split(":", 1)
                result[k.strip()] = v.strip()
        return result
