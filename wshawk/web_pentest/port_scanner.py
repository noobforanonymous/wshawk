"""
WSHawk TCP Port Scanner
Performs asynchronous TCP connect scans to identify open ports and services.
Supports custom port ranges, common port presets, and service banner grabbing.
"""

import asyncio
import socket
import time
from typing import Dict, Any, List, Optional


# Well-known port → service name mapping
SERVICE_MAP = {
    21: "FTP", 22: "SSH", 23: "Telnet", 25: "SMTP", 53: "DNS",
    80: "HTTP", 110: "POP3", 111: "RPCBind", 135: "MSRPC",
    139: "NetBIOS", 143: "IMAP", 389: "LDAP", 443: "HTTPS",
    445: "SMB", 465: "SMTPS", 514: "Syslog", 587: "SMTP/TLS",
    636: "LDAPS", 993: "IMAPS", 995: "POP3S", 1433: "MSSQL",
    1521: "Oracle", 2049: "NFS", 3306: "MySQL", 3389: "RDP",
    5432: "PostgreSQL", 5900: "VNC", 5985: "WinRM", 6379: "Redis",
    6443: "K8s API", 8080: "HTTP-Alt", 8443: "HTTPS-Alt",
    8888: "HTTP-Alt2", 9090: "Prometheus", 9200: "Elasticsearch",
    9443: "VSphere", 27017: "MongoDB", 11211: "Memcached",
}

# Preset port lists
PRESETS = {
    "top100": [
        21, 22, 23, 25, 53, 80, 110, 111, 135, 139, 143, 389, 443, 445,
        465, 514, 587, 636, 993, 995, 1433, 1521, 2049, 3306, 3389,
        5432, 5900, 5985, 6379, 6443, 8080, 8443, 8888, 9090, 9200,
        9443, 27017, 11211,
    ],
    "web": [80, 443, 8080, 8443, 8888, 3000, 5000, 9090, 9443],
    "database": [1433, 1521, 3306, 5432, 6379, 27017, 11211, 9200],
    "full": list(range(1, 1025)),
}


class WSHawkPortScanner:
    """
    Asynchronous TCP connect port scanner.

    Features:
        - Preset port lists (top100, web, database, full 1-1024)
        - Custom port ranges
        - Service identification via well-known port mapping
        - Banner grabbing on open ports
        - Concurrent scanning with configurable parallelism
    """

    def __init__(self, sio_instance=None):
        self.sio = sio_instance

    async def scan(
        self,
        host: str,
        ports: Optional[str] = None,
        preset: str = "top100",
        timeout_s: float = 2.0,
        grab_banners: bool = True,
    ) -> Dict[str, Any]:
        """
        Scan a host for open TCP ports.

        Args:
            host:          Target hostname or IP address.
            ports:         Custom port specification (e.g. '80,443,8000-8100').
                           If provided, overrides the preset.
            preset:        Preset port list ('top100', 'web', 'database', 'full').
            timeout_s:     Connection timeout per port in seconds.
            grab_banners:  If True, attempt banner grabbing on open ports.

        Returns:
            Dict with 'open_ports', 'closed_count', and scan timing.

        Raises:
            ValueError: If host is empty.
        """
        if not host or not host.strip():
            raise ValueError("Host is required")

        # Sanitize host — strip scheme and path
        host = (
            host.replace("https://", "")
            .replace("http://", "")
            .split("/")[0]
            .split(":")[0]
            .strip()
        )

        # ── Determine port list ──
        if ports and ports.strip():
            port_list = self._parse_ports(ports)
        else:
            port_list = list(PRESETS.get(preset, PRESETS["top100"]))

        if not port_list:
            raise ValueError("No ports to scan")

        # ── Scan ──
        start_time = time.time()
        open_ports: List[Dict] = []
        closed_count = 0
        sem = asyncio.Semaphore(100)  # Max concurrent connections

        async def _check_port(port: int):
            nonlocal closed_count
            async with sem:
                is_open = await self._tcp_connect(host, port, timeout_s)

                if is_open:
                    service = SERVICE_MAP.get(port, "Unknown")
                    banner = ""

                    if grab_banners:
                        banner = await self._grab_banner(host, port, timeout_s)

                    result = {
                        "port": port,
                        "state": "open",
                        "service": service,
                        "banner": banner,
                    }
                    open_ports.append(result)

                    # Emit real-time result
                    if self.sio:
                        await self.sio.emit("port_found", result)
                else:
                    closed_count += 1

        await asyncio.gather(*[_check_port(p) for p in port_list])

        elapsed = round(time.time() - start_time, 2)

        # Sort by port number
        open_ports.sort(key=lambda x: x["port"])

        result = {
            "host": host,
            "open_ports": open_ports,
            "open_count": len(open_ports),
            "closed_count": closed_count,
            "total_scanned": len(port_list),
            "elapsed": elapsed,
        }

        if self.sio:
            await self.sio.emit("portscan_done", result)

        return result

    async def _tcp_connect(self, host: str, port: int, timeout: float) -> bool:
        """Attempt a TCP connection to host:port."""
        try:
            _, writer = await asyncio.wait_for(
                asyncio.open_connection(host, port),
                timeout=timeout,
            )
            writer.close()
            await writer.wait_closed()
            return True
        except (asyncio.TimeoutError, ConnectionRefusedError, OSError):
            return False

    async def _grab_banner(self, host: str, port: int, timeout: float) -> str:
        """Attempt to read a service banner from an open port."""
        try:
            reader, writer = await asyncio.wait_for(
                asyncio.open_connection(host, port),
                timeout=timeout,
            )
            # Some services send banners immediately; wait briefly
            banner_data = await asyncio.wait_for(
                reader.read(256),
                timeout=2.0,
            )
            writer.close()
            await writer.wait_closed()
            return banner_data.decode('utf-8', errors='ignore').strip()
        except Exception:
            return ""

    def _parse_ports(self, spec: str) -> List[int]:
        """
        Parse a port specification string like '80,443,8000-8100'.

        Returns a deduplicated sorted list of port numbers.
        """
        ports = set()
        for part in spec.replace(" ", "").split(","):
            if not part:
                continue
            if "-" in part:
                try:
                    start, end = part.split("-", 1)
                    start_i, end_i = int(start), int(end)
                    if 1 <= start_i <= 65535 and 1 <= end_i <= 65535:
                        ports.update(range(start_i, end_i + 1))
                except ValueError:
                    pass
            else:
                try:
                    p = int(part)
                    if 1 <= p <= 65535:
                        ports.add(p)
                except ValueError:
                    pass

        return sorted(list(ports))[:10000]  # Cap at 10k ports max
