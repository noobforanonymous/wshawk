"""
WSHawk DNS / WHOIS Lookup Engine
Performs comprehensive DNS record enumeration and WHOIS information retrieval
using dnspython for reliable multi-type resolution and python-whois for
registration data.
"""

import asyncio
import socket
import time
from typing import Dict, Any, List

import dns.resolver
import dns.reversename
import dns.exception
import whois


# Record types to query
RECORD_TYPES = ["A", "AAAA", "MX", "NS", "TXT", "CNAME", "SOA", "SRV", "CAA"]


class WSHawkDNSLookup:
    """
    DNS and WHOIS information gathering engine.

    Uses dnspython for accurate multi-type DNS resolution and
    python-whois for WHOIS registration data.

    Features:
        - Multi-type DNS record resolution (A, AAAA, MX, NS, TXT, CNAME, SOA, SRV, CAA)
        - Reverse DNS lookup
        - WHOIS registration data with parsed fields
        - Concurrent queries for speed
    """

    async def lookup(self, domain: str) -> Dict[str, Any]:
        """
        Perform a full DNS + WHOIS lookup on a domain.

        Args:
            domain: Target domain name (e.g. 'example.com').

        Returns:
            Dict with 'dns_records', 'reverse_dns', 'whois', and timing info.

        Raises:
            ValueError: If domain is empty or invalid.
        """
        # Sanitize input
        domain = (
            domain.replace("https://", "")
            .replace("http://", "")
            .split("/")[0]
            .split(":")[0]
            .strip()
            .lower()
        )
        if not domain or "." not in domain:
            raise ValueError("Valid domain required (e.g. example.com)")

        start = time.time()

        # Run DNS + WHOIS concurrently
        dns_task = asyncio.to_thread(self._resolve_all, domain)
        whois_task = asyncio.to_thread(self._whois_query, domain)
        reverse_task = asyncio.to_thread(self._reverse_dns, domain)

        dns_results, whois_data, reverse = await asyncio.gather(
            dns_task, whois_task, reverse_task,
            return_exceptions=True,
        )

        # Handle exceptions gracefully
        if isinstance(dns_results, Exception):
            dns_results = {"error": str(dns_results)}
        if isinstance(whois_data, Exception):
            whois_data = {"raw": str(whois_data), "parsed": {}}
        if isinstance(reverse, Exception):
            reverse = ""

        elapsed = round(time.time() - start, 2)

        return {
            "domain": domain,
            "dns_records": dns_results,
            "reverse_dns": reverse,
            "whois": whois_data,
            "elapsed": elapsed,
        }

    def _resolve_all(self, domain: str) -> Dict[str, List[str]]:
        """Resolve all DNS record types using dnspython."""
        records: Dict[str, List[str]] = {}
        resolver = dns.resolver.Resolver()
        resolver.timeout = 5
        resolver.lifetime = 5

        for rtype in RECORD_TYPES:
            try:
                answers = resolver.resolve(domain, rtype)
                values = []

                for rdata in answers:
                    if rtype == "MX":
                        values.append(f"{rdata.preference} {rdata.exchange}")
                    elif rtype == "SOA":
                        values.append(
                            f"{rdata.mname} {rdata.rname} "
                            f"(serial: {rdata.serial}, refresh: {rdata.refresh}s, "
                            f"retry: {rdata.retry}s, expire: {rdata.expire}s)"
                        )
                    elif rtype == "SRV":
                        values.append(
                            f"{rdata.priority} {rdata.weight} {rdata.port} {rdata.target}"
                        )
                    elif rtype == "CAA":
                        values.append(f'{rdata.flags} {rdata.tag} "{rdata.value}"')
                    elif rtype == "TXT":
                        # TXT records come as byte strings
                        txt_val = rdata.to_text().strip('"')
                        values.append(txt_val)
                    else:
                        values.append(str(rdata))

                if values:
                    records[rtype] = values

            except dns.resolver.NoAnswer:
                pass  # Record type not available
            except dns.resolver.NXDOMAIN:
                records["error"] = ["Domain does not exist (NXDOMAIN)"]
                break
            except dns.exception.Timeout:
                pass  # Skip timed-out queries
            except Exception:
                pass  # Skip other errors

        return records

    def _reverse_dns(self, domain: str) -> str:
        """Perform reverse DNS lookup on the domain's primary IP."""
        try:
            ip = socket.gethostbyname(domain)
            rev_name = dns.reversename.from_address(ip)
            resolver = dns.resolver.Resolver()
            resolver.timeout = 3
            answers = resolver.resolve(rev_name, "PTR")
            ptrs = [str(rdata) for rdata in answers]
            return f"{ip} â†’ {', '.join(ptrs)}"
        except Exception:
            # Fallback to basic resolution
            try:
                ip = socket.gethostbyname(domain)
                hostname = socket.gethostbyaddr(ip)
                return f"{ip} â†’ {hostname[0]}"
            except Exception:
                return ""

    def _whois_query(self, domain: str) -> Dict[str, Any]:
        """Query WHOIS data using python-whois library."""
        try:
            w = whois.whois(domain)

            # Extract and normalize parsed fields
            parsed = {}

            if w.registrar:
                parsed["registrar"] = str(w.registrar)

            if w.creation_date:
                cd = w.creation_date
                if isinstance(cd, list):
                    cd = cd[0]
                parsed["created"] = str(cd)

            if w.updated_date:
                ud = w.updated_date
                if isinstance(ud, list):
                    ud = ud[0]
                parsed["updated"] = str(ud)

            if w.expiration_date:
                ed = w.expiration_date
                if isinstance(ed, list):
                    ed = ed[0]
                parsed["expires"] = str(ed)

            if w.name_servers:
                ns = w.name_servers
                if isinstance(ns, str):
                    ns = [ns]
                parsed["name_servers"] = [str(s).lower() for s in ns]

            if w.status:
                st = w.status
                if isinstance(st, str):
                    st = [st]
                parsed["status"] = list(st)

            if w.registrant:
                parsed["registrant"] = str(w.registrant)
            if w.org:
                parsed["organization"] = str(w.org)
            if w.country:
                parsed["country"] = str(w.country)
            if w.dnssec:
                parsed["dnssec"] = str(w.dnssec)

            # Raw text (truncated)
            raw_text = str(w.text) if hasattr(w, 'text') and w.text else ""
            if not raw_text:
                # Build a readable summary from parsed data
                lines = []
                for k, v in parsed.items():
                    if isinstance(v, list):
                        lines.append(f"{k}: {', '.join(v)}")
                    else:
                        lines.append(f"{k}: {v}")
                raw_text = "\n".join(lines)

            return {
                "raw": raw_text[:5000],
                "parsed": parsed,
                "server": getattr(w, 'registrar', 'unknown'),
            }

        except Exception as e:
            return {"raw": str(e), "parsed": {}, "server": "error"}
