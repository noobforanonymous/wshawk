"""
WSHawk CORS Misconfiguration Tester
Tests for common CORS misconfigurations that could allow cross-origin attacks.
Sends crafted Origin headers and analyzes Access-Control-* responses.
"""

import aiohttp
from urllib.parse import urlparse
from typing import Dict, Any, List


# Test origins to probe CORS behavior
def _build_test_origins(target: str) -> List[Dict[str, str]]:
    """Generate a list of crafted Origin values to test CORS policy."""
    parsed = urlparse(target)
    domain = parsed.hostname or ""
    scheme = parsed.scheme or "https"

    return [
        {
            "origin": f"{scheme}://evil.com",
            "name": "Arbitrary Origin",
            "desc": "Accepts any external origin",
            "severity": "High",
        },
        {
            "origin": "null",
            "name": "Null Origin",
            "desc": "Accepts null origin (sandboxed iframe / data URI attack)",
            "severity": "High",
        },
        {
            "origin": f"{scheme}://{domain}.evil.com",
            "name": "Subdomain Suffix",
            "desc": "Prefix matching only — accepts attacker-owned subdomain suffix",
            "severity": "High",
        },
        {
            "origin": f"{scheme}://evil{domain}",
            "name": "Domain Prefix Injection",
            "desc": "Weak regex — matches attacker domain appended to target",
            "severity": "High",
        },
        {
            "origin": f"{scheme}://subdomain.{domain}",
            "name": "Subdomain Reflection",
            "desc": "Reflects any subdomain — risky if subdomains are untrusted",
            "severity": "Medium",
        },
        {
            "origin": f"http://{domain}",
            "name": "HTTP Downgrade",
            "desc": "Allows HTTP origin when site uses HTTPS — MitM risk",
            "severity": "Medium",
        },
    ]


class WSHawkCORSTester:
    """
    Tests a target URL for CORS misconfigurations.

    Checks:
        - Wildcard (*) Access-Control-Allow-Origin
        - Origin reflection (mirrors any Origin back)
        - Null origin acceptance
        - Subdomain suffix / prefix attacks
        - HTTP downgrade on HTTPS sites
        - Credentials with wildcard origin
    """

    async def test(self, url: str) -> Dict[str, Any]:
        """
        Run CORS misconfiguration tests against a target URL.

        Args:
            url: Target URL to test.

        Returns:
            Dict with 'findings' list and 'risk_score'.

        Raises:
            ValueError: If URL is empty or missing scheme.
        """
        if not url or not url.strip():
            raise ValueError("URL is required")

        url = url.strip()
        if not url.startswith(("http://", "https://")):
            url = "https://" + url

        findings: List[Dict] = []
        test_origins = _build_test_origins(url)

        # ── Test 1: No Origin header (baseline response) ──
        baseline = await self._send_cors_request(url, origin=None)

        # Check for wildcard
        acao = baseline.get("acao", "")
        if acao == "*":
            acac = baseline.get("acac", "")
            findings.append({
                "test": "Wildcard Origin",
                "severity": "Medium" if acac.lower() != "true" else "High",
                "origin_sent": "(none)",
                "acao_received": "*",
                "credentials": acac.lower() == "true",
                "detail": "Access-Control-Allow-Origin is set to wildcard (*)"
                          + (". Combined with credentials=true — CRITICAL!" if acac.lower() == "true" else "."),
            })

        # ── Test 2: Probe each crafted origin ──
        for test in test_origins:
            try:
                resp = await self._send_cors_request(url, origin=test["origin"])
                acao = resp.get("acao", "")
                acac = resp.get("acac", "")

                # Check if origin was reflected
                if acao and (acao == test["origin"] or acao == "*"):
                    findings.append({
                        "test": test["name"],
                        "severity": test["severity"],
                        "origin_sent": test["origin"],
                        "acao_received": acao,
                        "credentials": acac.lower() == "true",
                        "detail": test["desc"],
                    })
            except Exception:
                pass  # Failed probes are expected

        # ── Risk score ──
        high_count = sum(1 for f in findings if f["severity"] == "High")
        med_count = sum(1 for f in findings if f["severity"] == "Medium")

        if high_count > 0:
            risk = "High"
        elif med_count > 0:
            risk = "Medium"
        elif findings:
            risk = "Low"
        else:
            risk = "Safe"

        return {
            "url": url,
            "findings": findings,
            "total": len(findings),
            "risk_score": risk,
        }

    async def _send_cors_request(
        self, url: str, origin: str = None
    ) -> Dict[str, str]:
        """Send a request with a custom Origin header and return CORS headers."""
        headers = {}
        if origin is not None:
            headers["Origin"] = origin

        timeout = aiohttp.ClientTimeout(total=10)
        async with aiohttp.ClientSession() as session:
            async with session.get(
                url, headers=headers, ssl=False,
                allow_redirects=True, timeout=timeout
            ) as resp:
                return {
                    "status": resp.status,
                    "acao": resp.headers.get("Access-Control-Allow-Origin", ""),
                    "acac": resp.headers.get("Access-Control-Allow-Credentials", ""),
                    "acam": resp.headers.get("Access-Control-Allow-Methods", ""),
                    "acah": resp.headers.get("Access-Control-Allow-Headers", ""),
                }
