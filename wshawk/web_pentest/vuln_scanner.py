"""
WSHawk Vulnerability Scanner
Orchestration engine that chains Crawler -> Header Analyzer -> Dir Scanner -> Fuzzer
into a single automated penetration test workflow.
"""

import asyncio
import time
from typing import Dict, Any, Optional
from .crawler import WSHawkCrawler
from .header_analyzer import WSHawkHeaderAnalyzer
from .dir_scanner import WSHawkDirScanner
from .fuzzer import WSHawkFuzzer
from .sensitive_finder import WSHawkSensitiveFinder
from .redirect_scanner import WSHawkRedirectHunter
from .ssrf_prober import WSHawkBlindProbe
import aiohttp


class WSHawkVulnScanner:
    """
    Automated vulnerability scanner that orchestrates multiple tools.
    
    Workflow:
        1. Crawl the target to discover pages, forms, and endpoints
        2. Analyze security headers on the main target
        3. Run directory scanning on discovered hosts
        4. Fuzz discovered forms / parameters with injection payloads
        5. Aggregate and score findings
    """

    def __init__(self, sio_instance=None):
        self.sio = sio_instance
        self.findings = []
        self._running = False

    async def _emit(self, event: str, data: Any):
        if self.sio:
            await self.sio.emit(event, data)

    async def _log(self, msg: str, level: str = "info"):
        await self._emit("vuln_log", {"msg": msg, "level": level, "ts": time.time()})

    async def run_scan(self, target_url: str, options: Optional[Dict] = None) -> Dict:
        """
        Full automated scan against a target URL.

        Options (all optional):
            crawl_depth:   int  (default 2)
            crawl_max:     int  (default 50)
            run_dirscan:   bool (default True)
            run_headers:   bool (default True)
            run_fuzz:      bool (default True)
            fuzz_wordlist: str  (default 'sqli')
        """
        if not options:
            options = {}

        self._running = True
        self.findings = []
        start = time.time()

        crawl_depth = options.get("crawl_depth", 2)
        crawl_max = options.get("crawl_max", 50)
        run_dirscan = options.get("run_dirscan", True)
        run_headers = options.get("run_headers", True)
        run_fuzz = options.get("run_fuzz", True)
        fuzz_wordlist = options.get("fuzz_wordlist", "sqli")
        req_headers = options.get("headers", {})
        req_cookies = options.get("cookies", {})

        await self._log(f"Starting automated scan on {target_url}")
        await self._emit("vuln_phase", {"phase": "crawl", "status": "running"})

        # ── Phase 1: Crawl ──
        crawler = WSHawkCrawler(sio_instance=self.sio)
        crawl_result = await crawler.crawl(
            target_url,
            max_depth=crawl_depth,
            max_pages=crawl_max,
            throttle_ms=30,
            headers=req_headers,
            cookies=req_cookies
        )

        pages = crawl_result.get("pages", [])
        forms = crawl_result.get("forms", [])
        api_endpoints = crawl_result.get("api_endpoints", [])
        sensitive_files = crawl_result.get("sensitive_files", [])
        csrf_tokens = crawl_result.get("csrf_tokens", [])
        stats = crawl_result.get("stats", {})

        if sensitive_files:
            for sfile in sensitive_files:
                self.findings.append({
                    "type": "sensitive_file",
                    "severity": "High",
                    "title": f"Sensitive File Exposed: {sfile['type']}",
                    "detail": "A sensitive configuration or metadata file is publicly accessible.",
                    "value": sfile["url"],
                    "url": sfile["url"]
                })

        await self._log(
            f"Crawl complete: {stats.get('pages_crawled', 0)} pages, "
            f"{stats.get('forms_found', 0)} forms, "
            f"{stats.get('api_endpoints_found', 0)} API endpoints"
        )
        await self._emit("vuln_phase", {"phase": "crawl", "status": "done", "stats": stats})

        if not self._running:
            return self._build_report(target_url, start)

        # ── Phase 2: Header Analysis ──
        if run_headers:
            await self._emit("vuln_phase", {"phase": "headers", "status": "running"})
            try:
                analyzer = WSHawkHeaderAnalyzer()
                header_results = await analyzer.analyze(target_url)

                for header_name, evaluation in header_results.items():
                    if evaluation.get("risk") in ("High", "Medium"):
                        self.findings.append({
                            "type": "header",
                            "severity": evaluation["risk"],
                            "title": f"Insecure Header: {header_name}",
                            "detail": evaluation["msg"],
                            "value": evaluation["value"],
                            "url": target_url
                        })

                await self._log(f"Header analysis done. {len([f for f in self.findings if f['type'] == 'header'])} issues found.")
            except Exception as e:
                await self._log(f"Header analysis failed: {str(e)}", "error")

            await self._emit("vuln_phase", {"phase": "headers", "status": "done"})

        if not self._running:
            return self._build_report(target_url, start)

        # ── Phase 3: Directory Scan ──
        if run_dirscan:
            await self._emit("vuln_phase", {"phase": "dirscan", "status": "running"})
            await self._log("Running directory scan...")

            # We use the WSHawkDirScanner but collect results via our own sio listener
            dir_engine = WSHawkDirScanner(sio_instance=self.sio)
            try:
                await dir_engine.scan_directories(target_url, "php,html,js,txt,bak,json,xml")
            except Exception as e:
                await self._log(f"Directory scan error: {str(e)}", "error")

            await self._emit("vuln_phase", {"phase": "dirscan", "status": "done"})

        if not self._running:
            return self._build_report(target_url, start)

        # ── Phase 4: Form / Parameter Fuzzing ──
        if run_fuzz and (forms or api_endpoints):
            await self._emit("vuln_phase", {"phase": "fuzz", "status": "running"})
            await self._log(f"Fuzzing {len(forms)} discovered forms and {len(api_endpoints)} API endpoints...")

            targets_to_fuzz = []
            for form in forms[:5]:  # Cap at 5 forms to avoid excessive scanning
                targets_to_fuzz.append({
                    "action": form.get("action", target_url),
                    "method": form.get("method", "GET"),
                    "inputs": form.get("inputs", []),
                    "is_api": False
                })
            
            for api in api_endpoints[:3]: # Cap at 3 APIs
                targets_to_fuzz.append({
                    "action": api,
                    "method": "POST",
                    "inputs": [],
                    "is_api": True
                })

            for target in targets_to_fuzz:
                action = target["action"]
                method = target["method"]
                inputs = target["inputs"]
                is_api = target["is_api"]

                # Build a fuzzable URL or Body with §FUZZ§ markers
                fuzz_url = action
                fuzz_body = ""
                fuzz_headers = dict(req_headers) # start with user-provided headers
                
                # Automatically add discovered CSRF token to headers for state changing requests
                if csrf_tokens and (is_api or method.upper() in ("POST", "PUT", "DELETE")):
                    fuzz_headers["X-CSRF-Token"] = csrf_tokens[0]
                
                if is_api:
                    fuzz_headers["Content-Type"] = "application/json"
                    fuzz_body = '{"data": "§FUZZ§", "id": 1}'
                elif method.upper() == "POST":
                    fuzz_headers["Content-Type"] = "application/x-www-form-urlencoded"
                    if inputs:
                        params = []
                        for inp in inputs:
                            name = inp.get("name", "")
                            if name:
                                # Inject payload into likely vulnerable fields
                                if "user" in name.lower() or "pass" in name.lower() or "email" in name.lower():
                                    params.append(f"{name}=§FUZZ§")
                                elif "csrf" in name.lower() or "token" in name.lower():
                                    # Use a discovered token instead of fuzzing the anti-csrf token itself
                                    token_val = inp.get("value") or (csrf_tokens[0] if csrf_tokens else "test")
                                    params.append(f"{name}={token_val}")
                                else:
                                    params.append(f"{name}=test")
                        if params and not any("§FUZZ§" in p for p in params):
                            params[0] = f"{inputs[0].get('name', 'input')}=§FUZZ§"
                        fuzz_body = "&".join(params)
                    else:
                        fuzz_body = "input=§FUZZ§"
                else:
                    if inputs:
                        param_name = inputs[0].get("name", "q")
                        fuzz_url = f"{action}?{param_name}=§FUZZ§"
                    else:
                        fuzz_url = f"{action}?input=§FUZZ§"

                try:
                    # Do not pass sio_instance so background fuzzing doesn't spam the UI's manual table
                    fuzz_engine = WSHawkFuzzer(sio_instance=None)
                    fuzz_res = await fuzz_engine.run_fuzz(
                        method=method,
                        url=fuzz_url,
                        body=fuzz_body,
                        headers=fuzz_headers,
                        cookies=req_cookies,
                        wordlist_name=fuzz_wordlist,
                        encoder="json" if is_api else "none",
                        grep_regex=r"(SQL syntax|mysql_|ORA-\d|syntax error|XPATH|Division by zero|Warning:.*\()"
                    )
                    
                    found_sqli = fuzz_res.get("findings", []) if isinstance(fuzz_res, dict) else []
                    unique_sqli = {f['payload']: f for f in found_sqli}.values()
                    
                    found_count = 0
                    for sqli_finding in list(unique_sqli):
                        if found_count >= 3:
                            break
                        
                        title = "Unknown"
                        detail = ""
                        severity = "Medium"
                        
                        if sqli_finding.get("auth_bypass"):
                            title = "Authentication Bypass / Status Deviation"
                            detail = f"Payload '{sqli_finding['payload']}' bypassed authentication logic (redirect/cookie/length anomaly)."
                            severity = "Critical"
                        elif sqli_finding.get("cmd"):
                            title = "Command / OS Injection"
                            detail = f"Payload '{sqli_finding['payload']}' triggered system command output."
                            severity = "Critical"
                        elif sqli_finding.get("lfi"):
                            title = "Local File Inclusion / Path Traversal"
                            detail = f"Payload '{sqli_finding['payload']}' leaked local system files."
                            severity = "Critical"
                        elif sqli_finding.get("xss"):
                            title = "Cross-Site Scripting (XSS) Reflection"
                            detail = f"Payload '{sqli_finding['payload']}' was reflected unsanitized in the response."
                            severity = "High"
                        elif sqli_finding.get("time_match"):
                            title = "Time-based Blind SQL Injection"
                            detail = f"Payload '{sqli_finding['payload']}' triggered a delay of >4 seconds (Took {sqli_finding['time']})."
                            severity = "High"
                        elif sqli_finding.get("grepped"):
                            title = "Database Error / SQL Injection"
                            detail = f"Payload '{sqli_finding['payload']}' triggered a database error reflection."
                            severity = "High"
                        
                        if detail:
                            self.findings.append({
                                "type": "fuzz",
                                "severity": severity,
                                "title": title,
                                "detail": detail,
                                "value": sqli_finding['payload'],
                                "url": action
                            })
                            
                            # ── Auto-Chaining: SQLi -> LFI ──
                            if "SQL Injection" in title:
                                await self._log(f"Auto-Chaining: Attempting SQLi to LFI escalation on {action}...", "warning")
                                try:
                                    escrow_url = fuzz_url.replace("§FUZZ§", "UNION SELECT load_file('/etc/passwd')")
                                    escrow_body = fuzz_body.replace("§FUZZ§", "UNION SELECT load_file('/etc/passwd')") if fuzz_body else None
                                    escrow_hdrs = {k: v.replace("§FUZZ§", "UNION SELECT load_file('/etc/passwd')") for k, v in fuzz_headers.items()} if fuzz_headers else None
                                    
                                    async with aiohttp.ClientSession(cookies=req_cookies) as session:
                                        async with session.request(method, escrow_url, data=escrow_body, headers=escrow_hdrs, ssl=False, allow_redirects=False, timeout=5) as resp:
                                            btext = await resp.text(errors='ignore')
                                            if "root:x:0:0:" in btext or btext.startswith("root:"):
                                                self.findings.append({
                                                    "type": "chain",
                                                    "severity": "Critical",
                                                    "title": "Chained Vulnerability: SQLi to LFI Escalation",
                                                    "detail": "Automated attack successfully escalated DB query to retrieve Local OS Files!",
                                                    "value": "UNION SELECT load_file('/etc/passwd')",
                                                    "url": action
                                                })
                                                await self._log("SUCCESS! Automated Chain leaked /etc/passwd!", "critical")
                                except Exception as e:
                                    pass

                            found_count += 1
                except Exception as e:
                    await self._log(f"Fuzz error on {action}: {str(e)}", "error")

                # Also check for CSRF (missing token) if it is a POST form
                if method.upper() == "POST":
                    has_token = any(
                        "csrf" in inp.get("name", "").lower() or "token" in inp.get("name", "").lower()
                        for inp in inputs
                    )
                    if not has_token:
                        self.findings.append({
                            "type": "csrf",
                            "severity": "High",
                            "title": "Missing Anti-CSRF Token",
                            "detail": "Form submits via POST but lacks a recognizable CSRF protection token parameter.",
                            "value": str([inp.get("name") for inp in inputs]),
                            "url": action
                        })

            await self._emit("vuln_phase", {"phase": "fuzz", "status": "done"})

        # ── Phase 4.5: Auto-Chaining (Redirect to SSRF) ──
        if run_fuzz and pages:
            await self._log("Scanning for Open Redirects & Auto-escalating to SSRF...")
            try:
                redirect_hunter = WSHawkRedirectHunter(sio_instance=None)
                ssrf_prober = WSHawkBlindProbe(sio_instance=None)
                
                param_pages = [p["url"] for p in pages if "?" in p["url"]]
                for purl in param_pages[:3]: # Cap at 3 for speed
                    redir_res = await redirect_hunter.scan(purl)
                    for rf in redir_res.get("findings", []):
                        self.findings.append({
                            "type": "redirect",
                            "severity": rf.get("severity", "Medium"),
                            "title": "Open Redirect",
                            "detail": f"Parameter '{rf.get('param', 'N/A')}' redirects to {rf.get('redirect_type', 'N/A')} ({rf.get('redirect_to', 'N/A')})",
                            "value": rf.get('payload', ''),
                            "url": purl
                        })
                        
                        await self._log(f"Auto-Chaining: Redirect triggered on '{rf.get('param')}', chaining to SSRF...", "warning")
                        ssrf_res = await ssrf_prober.probe(url=purl, param=rf.get('param'), method="GET")
                        for sf in ssrf_res.get("findings", []):
                            if sf.get("severity") == "High" or sf.get("indicators"):
                                self.findings.append({
                                    "type": "chain",
                                    "severity": "Critical",
                                    "title": "Chained Vulnerability: Open Redirect to SSRF",
                                    "detail": f"Auto-exploited Open Redirect on '{sf.get('param')}' to perform internal SSRF attacks (Found {sf.get('category')})!",
                                    "value": sf.get('payload', ''),
                                    "url": purl
                                })
                                await self._log("SUCCESS! Automated Chain escalated to SSRF!", "critical")
            except Exception as e:
                await self._log(f"Redirect/SSRF chaining error: {str(e)}", "error")


        # ── Phase 5: Data & Session Analysis ──
        if pages:
            await self._emit("vuln_phase", {"phase": "sensitive", "status": "running"})
            await self._log("Analyzing pages for sensitive data leaks and checking session cookies...")
            try:
                finder = WSHawkSensitiveFinder(sio_instance=None)
                page_urls = [p["url"] for p in pages]
                sens_res = await finder.scan_urls(page_urls)
                sens_findings = sens_res.get("findings", [])
                
                for f in sens_findings:
                    self.findings.append({
                        "type": f["type"],
                        "severity": f["severity"],
                        "title": f"Sensitive Data Exposure: {f['type']}",
                        "detail": "Sensitive information leaked in server response.",
                        "value": f["value"],
                        "url": f["url"]
                    })
                
                # Cookie Analysis via Forms Testing
                if forms:
                    async with aiohttp.ClientSession() as session:
                        for form in forms[:2]:
                            action = form.get("action", target_url)
                            if form.get("method", "GET").upper() == "POST":
                                try:
                                    async with session.post(action, ssl=False, allow_redirects=False, timeout=aiohttp.ClientTimeout(total=5)) as resp:
                                        for cookie_name, cookie_morsel in resp.cookies.items():
                                            if not cookie_morsel.get('httponly'):
                                                self.findings.append({
                                                    "type": "cookie",
                                                    "severity": "Medium",
                                                    "title": "Insecure Cookie: Missing HttpOnly",
                                                    "detail": f"Cookie '{cookie_name}' can be accessed via JavaScript.",
                                                    "value": cookie_name,
                                                    "url": action
                                                })
                                            if not cookie_morsel.get('secure'):
                                                self.findings.append({
                                                    "type": "cookie",
                                                    "severity": "Low",
                                                    "title": "Insecure Cookie: Missing Secure Flag",
                                                    "detail": f"Cookie '{cookie_name}' is transmitted over unencrypted HTTP.",
                                                    "value": cookie_name,
                                                    "url": action
                                                })
                                except Exception:
                                    pass

                await self._log(f"Session Analysis complete. {len(sens_findings)} leaks merged.")
            except Exception as e:
                await self._log(f"Sensitive analysis error: {str(e)}", "error")
            await self._emit("vuln_phase", {"phase": "sensitive", "status": "done"})

        # ── Finalize ──
        report = self._build_report(target_url, start)
        await self._emit("vuln_complete", report)
        await self._log(f"Scan complete. {len(self.findings)} findings in {report['elapsed']}s.")
        self._running = False

        return report

    def stop(self):
        """Stop a running scan."""
        self._running = False

    def _build_report(self, target: str, start_time: float) -> Dict:
        elapsed = round(time.time() - start_time, 2)

        severity_counts = {"High": 0, "Medium": 0, "Low": 0, "Info": 0}
        for f in self.findings:
            sev = f.get("severity", "Info")
            if sev in severity_counts:
                severity_counts[sev] += 1

        return {
            "target": target,
            "elapsed": elapsed,
            "total_findings": len(self.findings),
            "severity_counts": severity_counts,
            "findings": self.findings
        }
