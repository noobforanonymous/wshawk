"""
WSHawk Tech Stack Fingerprinter
Identifies CMS, frameworks, JavaScript libraries, and server technologies.
Works by analyzing HTTP headers, HTML meta tags, script sources, and response bodies.
"""

import aiohttp
import re
from typing import Dict, List, Any


# Fingerprint signatures: each entry maps a technology name to detection rules
SIGNATURES = {
    # ── Server Software ──
    "Nginx":           {"headers": {"server": r"nginx"}},
    "Apache":          {"headers": {"server": r"apache"}},
    "IIS":             {"headers": {"server": r"microsoft-iis"}},
    "LiteSpeed":       {"headers": {"server": r"litespeed"}},
    "Cloudflare":      {"headers": {"server": r"cloudflare"}, "cookies": r"__cflb|__cfuid|cf_clearance"},
    "AWS ELB":         {"headers": {"server": r"awselb"}},

    # ── Frameworks / Languages ──
    "PHP":             {"headers": {"x-powered-by": r"php"}},
    "ASP.NET":         {"headers": {"x-powered-by": r"asp\.net"}, "cookies": r"ASP\.NET_SessionId"},
    "Express.js":      {"headers": {"x-powered-by": r"express"}},
    "Django":          {"cookies": r"csrftoken", "body": r"csrfmiddlewaretoken"},
    "Ruby on Rails":   {"headers": {"x-powered-by": r"phusion"}, "cookies": r"_rails_session"},
    "Laravel":         {"cookies": r"laravel_session|XSRF-TOKEN"},
    "Spring":          {"headers": {"x-application-context": r".+"}, "cookies": r"JSESSIONID"},
    "Next.js":         {"headers": {"x-powered-by": r"next\.js"}, "body": r"_next/static|__NEXT_DATA__"},
    "Nuxt.js":         {"body": r"__nuxt|_nuxt/"},

    # ── CMS ──
    "WordPress":       {"body": r"wp-content|wp-includes|wp-json", "meta": r"WordPress"},
    "Joomla":          {"body": r"/media/jui/|/administrator/", "meta": r"Joomla"},
    "Drupal":          {"body": r"drupal\.settings|/sites/default/files", "headers": {"x-generator": r"drupal"}},
    "Shopify":         {"body": r"cdn\.shopify\.com|shopify-section"},
    "Wix":             {"body": r"wix\.com|wixstatic\.com"},
    "Squarespace":     {"body": r"squarespace\.com|static\.squarespace"},
    "Ghost":           {"body": r"ghost-url|ghost\.org"},

    # ── JS Libraries & Frameworks ──
    "jQuery":          {"body": r"jquery[\.\-]?\d|jquery\.min\.js"},
    "React":           {"body": r"react\.production\.min|__react|reactroot|_reactRootContainer"},
    "Vue.js":          {"body": r"vue\.min\.js|vue\.runtime|__vue__|v-cloak"},
    "Angular":         {"body": r"ng-version|ng-app|angular\.min\.js|angular\.io"},
    "Bootstrap":       {"body": r"bootstrap\.min\.css|bootstrap\.min\.js|bootstrap\.bundle"},
    "Tailwind CSS":    {"body": r"tailwindcss|tailwind\.min\.css"},

    # ── Analytics / Tracking ──
    "Google Analytics": {"body": r"google-analytics\.com/analytics|gtag\(|UA-\d{4,10}|G-[A-Z0-9]+"},
    "Google Tag Manager": {"body": r"googletagmanager\.com/gtm"},
    "Facebook Pixel":  {"body": r"connect\.facebook\.net/|fbq\("},
    "Hotjar":          {"body": r"hotjar\.com|hj\("},

    # ── CDN / Infrastructure ──
    "Cloudflare CDN":  {"headers": {"cf-ray": r".+"}},
    "Akamai":          {"headers": {"x-akamai-transformed": r".+"}},
    "Fastly":          {"headers": {"x-served-by": r"cache-", "via": r"varnish"}},
    "Vercel":          {"headers": {"x-vercel-id": r".+"}, "body": r"vercel\.app"},
    "Netlify":         {"headers": {"x-nf-request-id": r".+"}, "body": r"netlify"},

    # ── Security ──
    "reCAPTCHA":       {"body": r"recaptcha|grecaptcha"},
    "hCaptcha":        {"body": r"hcaptcha\.com"},
}


class WSHawkTechFingerprinter:
    """Detects technology stack by analyzing HTTP responses."""

    def __init__(self):
        pass

    async def fingerprint(self, url: str) -> Dict[str, Any]:
        """
        Analyze a target URL and return detected technologies.
        
        Returns:
            {
                "technologies": [{"name": "...", "category": "...", "confidence": "..."}],
                "raw_headers": {...},
                "meta_generator": "..."
            }
        """
        if not url:
            raise ValueError("URL required")
        url = url.strip()
        if not url.startswith(("http://", "https://")):
            url = "https://" + url

        detected = []

        async with aiohttp.ClientSession() as session:
            async with session.get(url, ssl=False, allow_redirects=True,
                                   timeout=aiohttp.ClientTimeout(total=10)) as resp:
                body = await resp.text(errors='ignore')
                headers = {k.lower(): v.lower() for k, v in resp.headers.items()}
                cookies_str = "; ".join([f"{k}={v.value}" for k, v in resp.cookies.items()])
                raw_headers = {k: v for k, v in resp.headers.items()}

        # Extract <meta name="generator"> content
        meta_gen = ""
        meta_match = re.search(r'<meta[^>]+name=["\']generator["\'][^>]+content=["\']([^"\']+)', body, re.IGNORECASE)
        if meta_match:
            meta_gen = meta_match.group(1)

        for tech_name, rules in SIGNATURES.items():
            matched = False
            match_sources = []

            # Check headers
            if "headers" in rules:
                for hdr_name, pattern in rules["headers"].items():
                    hdr_val = headers.get(hdr_name, "")
                    if hdr_val and re.search(pattern, hdr_val, re.IGNORECASE):
                        matched = True
                        match_sources.append(f"header:{hdr_name}")

            # Check cookies
            if "cookies" in rules and cookies_str:
                if re.search(rules["cookies"], cookies_str, re.IGNORECASE):
                    matched = True
                    match_sources.append("cookie")

            # Check body
            if "body" in rules:
                if re.search(rules["body"], body, re.IGNORECASE):
                    matched = True
                    match_sources.append("body")

            # Check meta generator
            if "meta" in rules and meta_gen:
                if re.search(rules["meta"], meta_gen, re.IGNORECASE):
                    matched = True
                    match_sources.append("meta:generator")

            if matched:
                # Determine category based on tech name
                category = _categorize(tech_name)
                confidence = "High" if len(match_sources) > 1 else "Medium"

                detected.append({
                    "name": tech_name,
                    "category": category,
                    "confidence": confidence,
                    "matched_via": match_sources
                })

        return {
            "technologies": detected,
            "raw_headers": raw_headers,
            "meta_generator": meta_gen,
            "count": len(detected)
        }


def _categorize(name: str) -> str:
    """Return category string for a technology name."""
    servers = {"Nginx", "Apache", "IIS", "LiteSpeed", "AWS ELB"}
    frameworks = {"PHP", "ASP.NET", "Express.js", "Django", "Ruby on Rails", "Laravel", "Spring", "Next.js", "Nuxt.js"}
    cms = {"WordPress", "Joomla", "Drupal", "Shopify", "Wix", "Squarespace", "Ghost"}
    js_libs = {"jQuery", "React", "Vue.js", "Angular", "Bootstrap", "Tailwind CSS"}
    analytics = {"Google Analytics", "Google Tag Manager", "Facebook Pixel", "Hotjar"}
    cdn = {"Cloudflare", "Cloudflare CDN", "Akamai", "Fastly", "Vercel", "Netlify"}
    security = {"reCAPTCHA", "hCaptcha"}

    if name in servers: return "Server"
    if name in frameworks: return "Framework"
    if name in cms: return "CMS"
    if name in js_libs: return "JS Library"
    if name in analytics: return "Analytics"
    if name in cdn: return "CDN/Infrastructure"
    if name in security: return "Security"
    return "Other"
