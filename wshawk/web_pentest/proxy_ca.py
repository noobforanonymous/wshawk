"""
WSHawk Proxy CA Engine
Generates and manages a root Certificate Authority for HTTPS traffic
interception. Creates per-host certificates signed by the WSHawk CA,
enabling transparent MITM proxying of encrypted traffic.
"""

import os
import ssl
import asyncio
import datetime
import ipaddress
from pathlib import Path
from typing import Dict, Any, Optional, Tuple

from cryptography import x509
from cryptography.x509.oid import NameOID, ExtendedKeyUsageOID
from cryptography.hazmat.primitives import hashes, serialization
from cryptography.hazmat.primitives.asymmetric import rsa


# Default paths
CA_DIR = Path.home() / ".wshawk" / "ca"
CA_KEY_FILE = CA_DIR / "wshawk_ca.key"
CA_CERT_FILE = CA_DIR / "wshawk_ca.pem"
CERTS_DIR = CA_DIR / "certs"


class WSHawkProxyCA:
    """
    Certificate Authority management for HTTPS interception.

    Generates a self-signed root CA that can be installed in browsers
    to enable transparent inspection of encrypted traffic. Creates
    per-host certificates on-the-fly, signed by the WSHawk CA.

    Features:
        - RSA 2048-bit root CA generation
        - 10-year CA validity
        - Per-host certificate generation with SAN support
        - Wildcard certificate support
        - CA certificate export for browser installation
        - Certificate caching to avoid regeneration
        - SSL context creation for proxy use
    """

    def __init__(self):
        self.ca_key: Optional[rsa.RSAPrivateKey] = None
        self.ca_cert: Optional[x509.Certificate] = None
        self._ensure_dirs()

    def _ensure_dirs(self):
        """Ensure CA directories exist."""
        CA_DIR.mkdir(parents=True, exist_ok=True)
        CERTS_DIR.mkdir(parents=True, exist_ok=True)

    async def generate_ca(self, force: bool = False) -> Dict[str, Any]:
        """
        Generate a new WSHawk root CA keypair and certificate.

        Args:
            force: If True, regenerate even if CA already exists.

        Returns:
            Dict with 'ca_cert_path', 'ca_key_path', and certificate info.
        """
        if CA_CERT_FILE.exists() and CA_KEY_FILE.exists() and not force:
            # Load existing CA
            self._load_ca()
            return {
                "status": "exists",
                "ca_cert_path": str(CA_CERT_FILE),
                "ca_key_path": str(CA_KEY_FILE),
                "subject": self._cert_subject(self.ca_cert),
                "expires": str(self.ca_cert.not_valid_after_utc),
                "fingerprint": self._cert_fingerprint(self.ca_cert),
                "msg": "CA already exists. Use force=true to regenerate.",
            }

        # Generate CA key
        ca_key = rsa.generate_private_key(
            public_exponent=65537,
            key_size=2048,
        )

        # Build CA certificate
        subject = issuer = x509.Name([
            x509.NameAttribute(NameOID.COUNTRY_NAME, "XX"),
            x509.NameAttribute(NameOID.STATE_OR_PROVINCE_NAME, "WSHawk"),
            x509.NameAttribute(NameOID.ORGANIZATION_NAME, "WSHawk Security Suite"),
            x509.NameAttribute(NameOID.COMMON_NAME, "WSHawk Root CA"),
        ])

        now = datetime.datetime.now(datetime.timezone.utc)

        ca_cert = (
            x509.CertificateBuilder()
            .subject_name(subject)
            .issuer_name(issuer)
            .public_key(ca_key.public_key())
            .serial_number(x509.random_serial_number())
            .not_valid_before(now)
            .not_valid_after(now + datetime.timedelta(days=3650))  # 10 years
            .add_extension(
                x509.BasicConstraints(ca=True, path_length=0),
                critical=True,
            )
            .add_extension(
                x509.KeyUsage(
                    digital_signature=True,
                    content_commitment=False,
                    key_encipherment=False,
                    data_encipherment=False,
                    key_agreement=False,
                    key_cert_sign=True,
                    crl_sign=True,
                    encipher_only=False,
                    decipher_only=False,
                ),
                critical=True,
            )
            .add_extension(
                x509.SubjectKeyIdentifier.from_public_key(ca_key.public_key()),
                critical=False,
            )
            .sign(ca_key, hashes.SHA256())
        )

        # Save key (encrypted-at-rest is optional; plain for ease of use)
        with open(CA_KEY_FILE, "wb") as f:
            f.write(ca_key.private_bytes(
                encoding=serialization.Encoding.PEM,
                format=serialization.PrivateFormat.TraditionalOpenSSL,
                encryption_algorithm=serialization.NoEncryption(),
            ))
        os.chmod(CA_KEY_FILE, 0o600)

        # Save cert
        with open(CA_CERT_FILE, "wb") as f:
            f.write(ca_cert.public_bytes(serialization.Encoding.PEM))

        self.ca_key = ca_key
        self.ca_cert = ca_cert

        return {
            "status": "generated",
            "ca_cert_path": str(CA_CERT_FILE),
            "ca_key_path": str(CA_KEY_FILE),
            "subject": self._cert_subject(ca_cert),
            "expires": str(ca_cert.not_valid_after_utc),
            "fingerprint": self._cert_fingerprint(ca_cert),
            "install_instructions": self._install_instructions(),
        }

    async def get_ca_info(self) -> Dict[str, Any]:
        """Get information about the current CA certificate."""
        if not CA_CERT_FILE.exists():
            return {"status": "not_found", "msg": "No CA generated yet."}

        self._load_ca()
        return {
            "status": "success",
            "ca_cert_path": str(CA_CERT_FILE),
            "subject": self._cert_subject(self.ca_cert),
            "expires": str(self.ca_cert.not_valid_after_utc),
            "fingerprint": self._cert_fingerprint(self.ca_cert),
            "install_instructions": self._install_instructions(),
            "cert_pem": CA_CERT_FILE.read_text(),
        }

    async def generate_host_cert(self, hostname: str) -> Dict[str, Any]:
        """
        Generate a certificate for a specific hostname, signed by the CA.

        Args:
            hostname: Target hostname (e.g., 'example.com').

        Returns:
            Dict with paths to the generated cert and key files.
        """
        if not hostname or not hostname.strip():
            raise ValueError("Hostname required")

        hostname = hostname.strip().lower()

        # Check cache
        cert_file = CERTS_DIR / f"{hostname}.pem"
        key_file = CERTS_DIR / f"{hostname}.key"

        if cert_file.exists() and key_file.exists():
            return {
                "status": "cached",
                "hostname": hostname,
                "cert_path": str(cert_file),
                "key_path": str(key_file),
            }

        # Ensure CA is loaded
        self._load_ca()

        # Generate host key
        host_key = rsa.generate_private_key(
            public_exponent=65537,
            key_size=2048,
        )

        now = datetime.datetime.now(datetime.timezone.utc)

        # Build SAN (Subject Alternative Name)
        san_entries = [x509.DNSName(hostname)]
        # Add wildcard
        if not hostname.startswith("*."):
            san_entries.append(x509.DNSName(f"*.{hostname}"))
        # Check if it's an IP
        try:
            ip = ipaddress.ip_address(hostname)
            san_entries.append(x509.IPAddress(ip))
        except ValueError:
            pass

        subject = x509.Name([
            x509.NameAttribute(NameOID.COMMON_NAME, hostname),
            x509.NameAttribute(NameOID.ORGANIZATION_NAME, "WSHawk Intercepted"),
        ])

        host_cert = (
            x509.CertificateBuilder()
            .subject_name(subject)
            .issuer_name(self.ca_cert.subject)
            .public_key(host_key.public_key())
            .serial_number(x509.random_serial_number())
            .not_valid_before(now)
            .not_valid_after(now + datetime.timedelta(days=365))
            .add_extension(
                x509.SubjectAlternativeName(san_entries),
                critical=False,
            )
            .add_extension(
                x509.BasicConstraints(ca=False, path_length=None),
                critical=True,
            )
            .add_extension(
                x509.ExtendedKeyUsage([
                    ExtendedKeyUsageOID.SERVER_AUTH,
                    ExtendedKeyUsageOID.CLIENT_AUTH,
                ]),
                critical=False,
            )
            .sign(self.ca_key, hashes.SHA256())
        )

        # Save
        with open(key_file, "wb") as f:
            f.write(host_key.private_bytes(
                encoding=serialization.Encoding.PEM,
                format=serialization.PrivateFormat.TraditionalOpenSSL,
                encryption_algorithm=serialization.NoEncryption(),
            ))
        os.chmod(key_file, 0o600)

        with open(cert_file, "wb") as f:
            f.write(host_cert.public_bytes(serialization.Encoding.PEM))

        return {
            "status": "generated",
            "hostname": hostname,
            "cert_path": str(cert_file),
            "key_path": str(key_file),
            "expires": str(host_cert.not_valid_after_utc),
            "san": [str(s) for s in san_entries],
        }

    def create_ssl_context(self, hostname: str) -> ssl.SSLContext:
        """
        Create an SSL context for intercepting a specific host.

        Args:
            hostname: Target hostname.

        Returns:
            Configured ssl.SSLContext with the host cert loaded.
        """
        cert_file = CERTS_DIR / f"{hostname}.pem"
        key_file = CERTS_DIR / f"{hostname}.key"

        if not cert_file.exists():
            raise FileNotFoundError(
                f"No certificate for {hostname}. Generate one first."
            )

        ctx = ssl.SSLContext(ssl.PROTOCOL_TLS_SERVER)
        ctx.load_cert_chain(str(cert_file), str(key_file))
        return ctx

    async def list_certs(self) -> Dict[str, Any]:
        """List all generated host certificates."""
        certs = []
        for f in sorted(CERTS_DIR.glob("*.pem")):
            hostname = f.stem
            key_exists = (CERTS_DIR / f"{hostname}.key").exists()
            stat = f.stat()
            certs.append({
                "hostname": hostname,
                "cert_path": str(f),
                "has_key": key_exists,
                "size": stat.st_size,
                "modified": datetime.datetime.fromtimestamp(
                    stat.st_mtime, tz=datetime.timezone.utc
                ).isoformat(),
            })

        return {
            "status": "success",
            "certs": certs,
            "count": len(certs),
            "ca_exists": CA_CERT_FILE.exists(),
        }

    async def cleanup_certs(self) -> Dict[str, Any]:
        """Remove all generated host certificates (keeps CA)."""
        removed = 0
        for f in CERTS_DIR.glob("*"):
            f.unlink()
            removed += 1

        return {"status": "success", "removed": removed}

    def _load_ca(self):
        """Load existing CA key and cert from disk."""
        if self.ca_key and self.ca_cert:
            return

        if not CA_KEY_FILE.exists() or not CA_CERT_FILE.exists():
            raise FileNotFoundError(
                "CA not generated. Run generate_ca() first."
            )

        with open(CA_KEY_FILE, "rb") as f:
            self.ca_key = serialization.load_pem_private_key(f.read(), password=None)

        with open(CA_CERT_FILE, "rb") as f:
            self.ca_cert = x509.load_pem_x509_certificate(f.read())

    def _cert_subject(self, cert: x509.Certificate) -> str:
        """Get human-readable subject from certificate."""
        return cert.subject.rfc4514_string()

    def _cert_fingerprint(self, cert: x509.Certificate) -> str:
        """Get SHA-256 fingerprint of certificate."""
        digest = cert.fingerprint(hashes.SHA256())
        return ":".join(f"{b:02X}" for b in digest)

    def _install_instructions(self) -> Dict[str, str]:
        """Return browser-specific CA installation instructions."""
        return {
            "firefox": (
                "Settings → Privacy & Security → Certificates → View Certificates → "
                f"Import → Select: {CA_CERT_FILE}"
            ),
            "chrome": (
                "Settings → Privacy and security → Security → Manage certificates → "
                f"Authorities → Import → Select: {CA_CERT_FILE}"
            ),
            "system_arch": (
                f"sudo trust anchor --store {CA_CERT_FILE}"
            ),
            "system_ubuntu": (
                f"sudo cp {CA_CERT_FILE} /usr/local/share/ca-certificates/wshawk.crt && "
                "sudo update-ca-certificates"
            ),
            "curl": f"curl --cacert {CA_CERT_FILE} https://example.com",
        }
