"""
WSHawk WAF Detector Engine
Identifies Web Application Firewalls protecting a target by analyzing
response headers, status codes, cookies, and body fingerprints.
"""

import aiohttp
import re
from typing import Dict, Any, List, Optional


# WAF signature database — each entry maps a WAF name to detection rules
WAF_SIGNATURES = {
    "Cloudflare": {
        "headers": {"server": r"cloudflare", "cf-ray": r".+"},
        "cookies": r"__cflb|__cfuid|cf_clearance|__cf_bm",
        "body": r"cloudflare|ray id|cf-error",
    },
    "AWS WAF": {
        "headers": {"x-amzn-requestid": r".+", "x-amz-cf-id": r".+"},
        "body": r"aws|amazonaws",
    },
    "Akamai": {
        "headers": {"x-akamai-transformed": r".+", "server": r"akamai"},
        "body": r"akamai|reference.*#\d+\.\w+",
    },
    "ModSecurity": {
        "headers": {"server": r"mod_security|modsecurity"},
        "body": r"mod_security|modsecurity|not acceptable|406 not acceptable",
    },
    "Sucuri": {
        "headers": {"server": r"sucuri", "x-sucuri-id": r".+"},
        "body": r"sucuri|cloudproxy",
    },
    "Imperva / Incapsula": {
        "headers": {"x-iinfo": r".+", "x-cdn": r"incapsula"},
        "cookies": r"incap_ses|visid_incap",
        "body": r"incapsula|imperva",
    },
    "F5 BIG-IP ASM": {
        "headers": {"server": r"big-?ip", "x-wa-info": r".+"},
        "cookies": r"TS[a-z0-9]{6,}|BIGipServer",
        "body": r"the requested url was rejected",
    },
    "Barracuda": {
        "headers": {"server": r"barracuda"},
        "cookies": r"barra_counter_session",
        "body": r"barracuda",
    },
    "Fortinet FortiWeb": {
        "headers": {"server": r"fortiweb"},
        "cookies": r"FORTIWAFSID",
        "body": r"fortigate|fortinet",
    },
    "Wordfence (WordPress)": {
        "body": r"wordfence|wfwaf-authcookie|generated by wordfence",
    },
    "DenyAll": {
        "headers": {"server": r"denyall"},
        "cookies": r"sessioncookie",
    },
    "Citrix NetScaler": {
        "headers": {"via": r"ns-cache", "cneonction": r".+"},
        "cookies": r"ns_af|citrix_ns_id|NSC_",
        "body": r"ns transaction id|citrix",
    },
    "Radware AppWall": {
        "headers": {"x-sl-compstate": r".+"},
        "body": r"radware|unauthorized activity",
    },
    "StackPath": {
        "headers": {"x-sp-url": r".+", "x-sp-waf": r".+"},
        "body": r"stackpath",
    },
    "Varnish": {
        "headers": {"via": r"varnish", "x-varnish": r".+"},
    },
}

# Payloads designed to trigger WAF responses
PROBE_PAYLOADS = [
    "?test=<script>alert(1)</script>",
    "?id=1' OR '1'='1",
    "?file=../../../../etc/passwd",
    "?cmd=;cat /etc/passwd",
]


class WSHawkWAFDetector:
    """
    Detects Web Application Firewalls by sending probe requests
    and analyzing response fingerprints.

    Detection methods:
        1. Normal request header/cookie analysis
        2. Malicious payload probing to trigger WAF block pages
        3. Response body fingerprint matching
    """

    async def detect(self, url: str) -> Dict[str, Any]:
        """
        Detect WAFs protecting a target URL.

        Args:
            url: Target URL to probe.

        Returns:
            Dict with 'detected' list, 'blocked' status, and raw 'evidence'.

        Raises:
            ValueError: If URL is empty.
        """
        if not url or not url.strip():
            raise ValueError("URL is required")

        url = url.strip()
        if not url.startswith(("http://", "https://")):
            url = "https://" + url

        detected: List[Dict] = []
        evidence: List[str] = []
        blocked = False

        # ── Phase 1: Passive — analyze normal response ──
        try:
            normal = await self._fetch(url)
            passive_hits = self._match_signatures(normal)
            for waf_name, sources in passive_hits.items():
                detected.append({
                    "name": waf_name,
                    "method": "passive",
                    "matched_via": sources,
                })
                evidence.append(f"[Passive] {waf_name} via {', '.join(sources)}")
        except Exception as e:
            evidence.append(f"[Error] Normal request failed: {str(e)}")

        # ── Phase 2: Active — send malicious probes ──
        for probe in PROBE_PAYLOADS:
            probe_url = url.rstrip("/") + probe
            try:
                resp = await self._fetch(probe_url)

                # Check if we got blocked (403, 406, 429, 503)
                if resp["status"] in (403, 406, 429, 503):
                    blocked = True
                    evidence.append(
                        f"[Probe] {probe[:30]}... → HTTP {resp['status']}"
                    )

                probe_hits = self._match_signatures(resp)
                for waf_name, sources in probe_hits.items():
                    # Avoid duplicates
                    if not any(d["name"] == waf_name for d in detected):
                        detected.append({
                            "name": waf_name,
                            "method": "active",
                            "matched_via": sources,
                        })
                    evidence.append(
                        f"[Active] {waf_name} via {', '.join(sources)}"
                    )
            except Exception:
                pass  # Probe failures are expected

        return {
            "url": url,
            "detected": detected,
            "blocked": blocked,
            "waf_count": len(detected),
            "evidence": evidence,
        }

    async def _fetch(self, url: str) -> Dict[str, Any]:
        """Fetch a URL and return normalized response data for matching."""
        timeout = aiohttp.ClientTimeout(total=10)
        async with aiohttp.ClientSession() as session:
            async with session.get(
                url, ssl=False, allow_redirects=True, timeout=timeout
            ) as resp:
                body = await resp.text(errors='ignore')
                headers = {k.lower(): v.lower() for k, v in resp.headers.items()}
                cookies_str = "; ".join(
                    f"{k}={v.value}" for k, v in resp.cookies.items()
                )
                return {
                    "status": resp.status,
                    "headers": headers,
                    "cookies": cookies_str,
                    "body": body[:10000],  # Cap body to prevent memory issues
                }

    def _match_signatures(self, resp: Dict[str, Any]) -> Dict[str, List[str]]:
        """Match response data against the WAF signature database."""
        hits: Dict[str, List[str]] = {}

        for waf_name, rules in WAF_SIGNATURES.items():
            matched_sources: List[str] = []

            # Check headers
            if "headers" in rules:
                for hdr, pattern in rules["headers"].items():
                    if hdr in resp["headers"]:
                        if re.search(pattern, resp["headers"][hdr], re.IGNORECASE):
                            matched_sources.append(f"header:{hdr}")

            # Check cookies
            if "cookies" in rules and resp.get("cookies"):
                if re.search(rules["cookies"], resp["cookies"], re.IGNORECASE):
                    matched_sources.append("cookie")

            # Check response body
            if "body" in rules and resp.get("body"):
                if re.search(rules["body"], resp["body"], re.IGNORECASE):
                    matched_sources.append("body")

            if matched_sources:
                hits[waf_name] = matched_sources

        return hits
