"""
WSHawk Redirect Hunter Engine
Scans URL parameters for Open Redirect vulnerabilities by injecting various
redirect payloads and analyzing response behavior (3xx redirects, meta
refresh, JavaScript redirects).
"""

import aiohttp
import asyncio
import re
import time
from urllib.parse import urlparse, parse_qs, urlencode, urlunparse
from typing import Dict, Any, List


# Redirect payloads designed to test different bypass techniques
REDIRECT_PAYLOADS = [
    # Basic absolute URLs
    ("Absolute URL", "https://evil.com"),
    ("Absolute HTTP", "http://evil.com"),

    # Protocol-relative
    ("Protocol Relative", "//evil.com"),
    ("Protocol Relative Path", "//evil.com/path"),

    # Backslash trick
    ("Backslash Bypass", "\\\\evil.com"),
    ("Forward-Back Mix", "/\\evil.com"),

    # URL encoding bypasses
    ("URL Encoded", "https%3A%2F%2Fevil.com"),
    ("Double Encoded", "https%253A%252F%252Fevil.com"),
    ("Unicode Dot", "https://evil%E3%80%82com"),

    # Domain confusion
    ("At-Sign Bypass", "https://target.com@evil.com"),
    ("Subdomain Spoof", "https://target.com.evil.com"),
    ("Tab Injection", "https://evil.com%09"),
    ("Null Byte", "https://evil.com%00"),

    # JavaScript URI
    ("JS Protocol", "javascript:alert(document.domain)//"),
    ("JS Data URI", "data:text/html,<script>alert(1)</script>"),

    # Relative path escapes
    ("Dotdot Slash", "/../../../evil.com"),
    ("Path Traversal", "/..;/evil.com"),
    ("Root Redirect", "///evil.com"),
    ("Four Slashes", "////evil.com"),

    # CRLF injection in redirect
    ("CRLF Header", "%0d%0aLocation:%20https://evil.com"),

    # Scheme-less
    ("Schemeless", "evil.com"),

    # IP-based
    ("Localhost Redirect", "http://127.0.0.1"),
    ("Internal Redirect", "http://192.168.1.1"),
]

# Parameter names commonly used for redirects
REDIRECT_PARAMS = {
    "url", "redirect", "redirect_uri", "redirect_url", "next", "return",
    "return_to", "returnurl", "returnto", "redir", "destination", "dest",
    "continue", "forward", "go", "goto", "target", "to", "out", "view",
    "link", "callback", "fallback", "checkout_url", "login_url",
    "success_url", "error_url", "cancel_url", "ref", "site",
}


class WSHawkRedirectHunter:
    """
    Scans for Open Redirect vulnerabilities in URL parameters.

    Tests redirect-like parameters with 25+ bypass techniques including
    protocol-relative URLs, encoding tricks, JavaScript URIs, and
    CRLF injection.

    Features:
        - Auto-detects redirect parameters by name
        - 25+ payload variations covering all major bypass categories
        - Detects 3xx redirects, meta refresh, and JS-based redirects
        - Severity scoring based on redirect type and destination
        - Real-time Socket.IO progress updates
    """

    def __init__(self, sio_instance=None):
        self.sio = sio_instance

    async def scan(
        self, url: str, param: str = "",
        custom_payloads: List[str] = None,
    ) -> Dict[str, Any]:
        """
        Scan a URL for open redirect vulnerabilities.

        Args:
            url: Target URL with parameters.
            param: Specific parameter to test (auto-detects if empty).
            custom_payloads: Additional redirect payloads.

        Returns:
            Dict with 'findings', 'params_tested', 'payloads_sent'.
        """
        if not url or not url.strip():
            raise ValueError("URL is required")

        url = url.strip()
        if not url.startswith(("http://", "https://")):
            url = "https://" + url

        start = time.time()
        findings: List[Dict] = []
        payloads_sent = 0

        parsed = urlparse(url)
        query_params = parse_qs(parsed.query, keep_blank_values=True)

        # Find testable params
        target_params = []
        if param:
            target_params = [param]
        else:
            for k in query_params:
                if k.lower() in REDIRECT_PARAMS:
                    target_params.append(k)

        if not target_params:
            # If no known redirect params, test all params
            target_params = list(query_params.keys())

        if not target_params:
            return {
                "url": url,
                "findings": [],
                "params_tested": [],
                "payloads_sent": 0,
                "elapsed": round(time.time() - start, 2),
                "note": "No parameters found in URL. Add ?param=value to test."
            }

        # Build payloads
        all_payloads = list(REDIRECT_PAYLOADS)
        if custom_payloads:
            for p in custom_payloads:
                all_payloads.append(("Custom", p))

        sem = asyncio.Semaphore(5)

        async def _test(param_name: str, payload_name: str, payload: str):
            nonlocal payloads_sent
            async with sem:
                payloads_sent += 1
                try:
                    test_params = dict(query_params)
                    test_params[param_name] = [payload]
                    new_query = urlencode(test_params, doseq=True)
                    test_url = urlunparse((
                        parsed.scheme, parsed.netloc, parsed.path,
                        parsed.params, new_query, parsed.fragment
                    ))

                    timeout = aiohttp.ClientTimeout(total=8)
                    async with aiohttp.ClientSession() as session:
                        async with session.get(
                            test_url, ssl=False,
                            allow_redirects=False, timeout=timeout
                        ) as resp:
                            status = resp.status
                            location = resp.headers.get("Location", "")
                            body = await resp.text(errors='ignore')
                            body = body[:3000]

                    # Analyze for redirect
                    redirect_type = None
                    redirect_dest = ""

                    # 3xx redirect with external Location
                    if 300 <= status < 400 and location:
                        if self._is_external(location, parsed.netloc):
                            redirect_type = "HTTP 3xx Redirect"
                            redirect_dest = location

                    # Meta refresh redirect
                    meta_match = re.search(
                        r'<meta[^>]+http-equiv=["\']refresh["\'][^>]+content=["\'][^"\']*url=([^"\'>\s]+)',
                        body, re.IGNORECASE
                    )
                    if meta_match:
                        dest = meta_match.group(1)
                        if self._is_external(dest, parsed.netloc):
                            redirect_type = "Meta Refresh"
                            redirect_dest = dest

                    # JavaScript redirect
                    js_patterns = [
                        r'window\.location\s*=\s*["\']([^"\']+)',
                        r'location\.href\s*=\s*["\']([^"\']+)',
                        r'location\.replace\(["\']([^"\']+)',
                        r'window\.open\(["\']([^"\']+)',
                    ]
                    for jp in js_patterns:
                        js_match = re.search(jp, body, re.IGNORECASE)
                        if js_match:
                            dest = js_match.group(1)
                            if self._is_external(dest, parsed.netloc):
                                redirect_type = "JavaScript Redirect"
                                redirect_dest = dest
                                break

                    if redirect_type:
                        severity = "High" if redirect_type == "HTTP 3xx Redirect" else "Medium"
                        finding = {
                            "param": param_name,
                            "payload_name": payload_name,
                            "payload": payload,
                            "redirect_type": redirect_type,
                            "redirect_to": redirect_dest,
                            "status": status,
                            "severity": severity,
                        }
                        findings.append(finding)

                        if self.sio:
                            await self.sio.emit("redirect_finding", finding)

                except asyncio.TimeoutError:
                    pass
                except Exception:
                    pass

        tasks = []
        for param_name in target_params:
            for payload_name, payload in all_payloads:
                tasks.append(_test(param_name, payload_name, payload))

        await asyncio.gather(*tasks)

        elapsed = round(time.time() - start, 2)

        return {
            "url": url,
            "findings": findings,
            "params_tested": target_params,
            "payloads_sent": payloads_sent,
            "total_findings": len(findings),
            "elapsed": elapsed,
        }

    def _is_external(self, dest: str, original_host: str) -> bool:
        """Check if a redirect destination points outside the original host."""
        if not dest:
            return False

        # Remove any whitespace
        dest = dest.strip()

        # Protocol-relative or absolute
        if dest.startswith("//"):
            parsed_dest = urlparse("https:" + dest)
            return parsed_dest.hostname != original_host

        if dest.startswith(("http://", "https://")):
            parsed_dest = urlparse(dest)
            return parsed_dest.hostname != original_host

        # JavaScript/data URIs are always "external"
        if dest.lower().startswith(("javascript:", "data:", "vbscript:")):
            return True

        return False
