"""
WSHawk HTTP Proxy Engine
Sends raw HTTP requests via Python to bypass browser CORS constraints.
Used by the HTTP Forge tab in the desktop UI.
"""

import aiohttp
from typing import Dict, Any


class WSHawkHTTPProxy:
    """Proxies HTTP requests natively, returning status, headers, and body."""

    # Maximum response body size to prevent memory issues (5MB)
    MAX_BODY_SIZE = 5 * 1024 * 1024

    async def send_request(self, method: str, url: str,
                           headers_str: str = "", body: str = "") -> Dict[str, Any]:
        """
        Send an HTTP request and return the raw response.

        Args:
            method:      HTTP method (GET, POST, PUT, DELETE, etc.).
            url:         Full target URL including scheme.
            headers_str: Newline-separated headers in 'Key: Value' format.
            body:        Optional request body string.

        Returns:
            Dict with 'status', 'headers', and 'body' keys.

        Raises:
            ValueError: If the URL is empty or the method is invalid.
        """
        # ── Input validation ──
        if not url or not url.strip():
            raise ValueError("URL is required")

        method = method.strip().upper()
        valid_methods = {"GET", "POST", "PUT", "DELETE", "PATCH", "HEAD", "OPTIONS"}
        if method not in valid_methods:
            raise ValueError(f"Invalid HTTP method: {method}")

        if not url.startswith(("http://", "https://")):
            url = "https://" + url

        # ── Parse custom headers ──
        headers: Dict[str, str] = {}
        if headers_str:
            for line in headers_str.split('\n'):
                line = line.strip()
                if ':' in line:
                    key, value = line.split(':', 1)
                    headers[key.strip()] = value.strip()

        # ── Make request ──
        timeout = aiohttp.ClientTimeout(total=30)
        async with aiohttp.ClientSession(headers=headers) as session:
            async with session.request(
                method, url,
                data=body.encode('utf-8') if body else None,
                ssl=False,
                allow_redirects=False,
                timeout=timeout
            ) as resp:
                # Cap body size to prevent OOM on huge responses
                raw_body = await resp.read()
                if len(raw_body) > self.MAX_BODY_SIZE:
                    resp_text = raw_body[:self.MAX_BODY_SIZE].decode('utf-8', errors='ignore')
                    resp_text += f"\n\n[TRUNCATED — Response exceeded {self.MAX_BODY_SIZE // 1024}KB]"
                else:
                    resp_text = raw_body.decode('utf-8', errors='ignore')

                resp_headers_str = "\n".join(
                    f"{k}: {v}" for k, v in resp.headers.items()
                )

                return {
                    "status": str(resp.status),
                    "headers": resp_headers_str,
                    "body": resp_text
                }
