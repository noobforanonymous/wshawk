# WSHawk V3.0.3: Release Guide and Technical Reference
## Headless DOM Invader, AI Exploit Engine, and Auth Flow Automation

---

## Table of Contents

1.  **[Introduction](#1-introduction)**
    - Release Overview
    - What Changed from V3.0.2
2.  **[DOM Invader Architecture](#2-dom-invader)**
    - Design Rationale
    - BrowserPool: Reusable Context Management
    - XSSVerifier: Headless Execution Confirmation
    - AuthFlowRecorder: SSO and OAuth Session Automation
    - DOMInvader: Orchestrator Interface
3.  **[XSS Verification: Technical Deep Dive](#3-xss-verification)**
    - Why String Matching Fails
    - Instrumented Page Architecture
    - Execution Detection Hierarchy
    - Supported XSS Technique Classifications
4.  **[Auth Flow Recording and Replay](#4-auth-flow)**
    - Problem Statement: Long-Running Scan Sessions
    - Recording Procedure
    - Token Capture Logic
    - Headless Replay Mechanics
    - Auto-Reconnect Integration with Blaster
5.  **[Payload Blaster: V3.0.3 Updates](#5-blaster)**
    - New Parameters: `dom_verify` and `auth_flow`
    - DOM Verified Results Column
    - Session Expiry Handling and Reconnect Logic
    - Rate Behaviour Changes
6.  **[AI Exploit Engine](#6-ai-exploit-engine)**
    - Architecture
    - Context Detection: JSON, XML, URL, Raw
    - AI Provider Configuration
    - Fallback Static Payload System
    - Blaster Template Auto-Population
7.  **[REST API: New V3.0.3 Endpoints](#7-api)**
    - `GET /dom/status`
    - `POST /dom/verify`
    - `POST /dom/verify/batch`
    - `POST /dom/auth/record`
    - `POST /dom/auth/replay`
    - `POST /ai/context-exploit`
8.  **[Frontend Changes: Blaster Panel](#8-frontend)**
    - DOM Invader Control Block
    - Status Pill Behaviour
    - Record Auth Flow Button
    - DOM Verified Column in Results Table
9.  **[PyInstaller Spec Updates](#9-pyinstaller)**
    - New Hidden Imports
    - Playwright Handling
10. **[Deployment and Installation](#10-deployment)**
    - Playwright System Requirements
    - Sandboxed Chromium Flags
    - CI/CD Considerations
11. **[Upgrade Path from V3.0.2](#11-upgrade)**
    - Breaking Changes
    - New Optional Dependencies
12. **[Troubleshooting](#12-troubleshooting)**
    - Playwright Not Detected
    - Auth Replay Returning Empty Tokens
    - DOM Verification Timing Out
13. **[Glossary](#13-glossary)**
14. **[Support](#14-support)**

---

## 1. Introduction <a name="1-introduction"></a>

### Release Overview

WSHawk V3.0.3 is a focused capability release built around a single critical gap in modern WebSocket security tooling: the inability to confirm whether an XSS payload has actually executed in a browser runtime. String-matching and reflection-based detection produce high volumes of false positives. A payload that is reflected in a server response may still be safely encoded, sandboxed, or stripped by the browser's content security policy. V3.0.3 introduces a headless Chromium execution layer — the DOM Invader — that renders every WebSocket response in an instrumented browser page and observes whether JavaScript execution actually occurs.

The second gap addressed in this release is session continuity during extended fuzzing operations. Long-running Payload Blaster sessions against authenticated endpoints lose their connection when tokens expire, typically between 15 and 60 minutes into a scan. Previous versions required the user to manually restart the session. V3.0.3 introduces recorded auth flow replay: the user records a single login in a visible browser session, and every subsequent token refresh is handled automatically.

### What Changed from V3.0.2

| Area | V3.0.2 Behaviour | V3.0.3 Behaviour |
| :--- | :--- | :--- |
| XSS Detection | Reflection string matching | Headless browser execution confirmation |
| Blaster Session Handling | Manual restart required on expiry | Auto-replay of recorded auth flow |
| AI Payload Generation | Not available | Right-click context menu in ReqForge |
| Playwright in Packaged Binary | Excluded from PyInstaller bundle | Included via explicit hiddenimports |
| Blaster Results Table | 5 columns | 6 columns with DOM Verified status |
| Backend API Routes | No DOM-specific routes | 5 new `/dom/*` routes |

---

## 2. DOM Invader Architecture <a name="2-dom-invader"></a>

### Design Rationale

The DOM Invader follows the same layered pattern used elsewhere in WSHawk: a standalone engine module (`dom_invader.py`) that contains all business logic, thin REST routes in `gui_bridge.py` that handle HTTP concerns only, and a frontend module in `renderer.js` that manages UI state. No business logic lives in the routing layer.

The engine is structured as three independent classes coordinated by a single orchestrator:

```
DOMInvader (orchestrator)
    BrowserPool     → manages reusable Chromium contexts
    XSSVerifier     → confirms actual JS execution
    AuthFlowRecorder → records and replays SSO/OAuth flows
```

### BrowserPool: Reusable Context Management

Launching a Chromium instance is an expensive operation — typically 800ms to 1.5 seconds on a standard workstation. Running a fresh browser for every payload verification would make the Blaster unusable at any serious fuzzing rate. The `BrowserPool` addresses this by maintaining a pool of pre-warmed `BrowserContext` objects that are cleared between uses rather than destroyed and recreated.

The pool is initialized once when the first verification request arrives and persists for the lifetime of the backend process:

```python
class BrowserPool:
    async def start(self, headless=True, max_contexts=4)
    async def get_context() -> BrowserContext
    async def release_context(ctx)
    async def shutdown()
```

Context isolation is maintained by clearing cookies and closing all pages before returning a context to the available pool. If a context raises an exception during cleanup — indicating it has entered a broken state — it is closed and discarded rather than returned.

The pool supports a configurable maximum of concurrent contexts. When demand exceeds the pool size, the `get_context()` call blocks until a context becomes available rather than creating an unbounded number of browser tabs.

### XSSVerifier: Headless Execution Confirmation

The `XSSVerifier` receives two inputs: the raw WebSocket response body and the original payload that was sent. It renders the response body as the content of a sandboxed `<div>` element inside a purpose-built HTML page, applies a comprehensive instrumentation layer, and waits a configurable number of milliseconds for any deferred JavaScript execution to complete.

The instrumentation layer consists of:

- Overrides for `window.alert()`, `window.confirm()`, and `window.prompt()` that set a global `window.__xss_executed` flag and capture the message text.
- An override for `window.eval()` that records eval-based execution attempts.
- A `MutationObserver` monitoring the response container for newly injected child nodes, specifically `<script>` elements and elements carrying inline event handler attributes.
- A mutation counter accessible via `window.__mutation_count` for post-execution inspection.

After the wait period, the verifier reads the execution state via a single `page.evaluate()` call and classifies the result. Detection is hierarchical: a triggered dialog is the highest-confidence indicator, followed by the `eval` override, followed by injected script tags, followed by event handler attributes. Any positive detection triggers a `dom_xss_confirmed` Socket.IO event to the frontend.

### AuthFlowRecorder: SSO and OAuth Session Automation

The `AuthFlowRecorder` addresses the practical challenge of authenticating against applications that use multi-step login flows: SSO redirects, OAuth consent screens, CAPTCHA challenges, MFA prompts, or custom JavaScript-rendered login forms. These flows cannot be reliably automated with simple username/password field injection.

The solution is to let the user complete the login manually in a visible browser while the recorder observes the network activity and extracts the resulting session material. The recording phase uses `headless=False` so the user can interact with the page as they would in a normal browser session.

The recorder captures:
- All cookies set during the authenticated session
- JSON response bodies matching known token key patterns (`token`, `access_token`, `jwt`, `session_token`, `auth_token`, `sessionId`)
- `Authorization` headers present on any outgoing request during the session
- The full `localStorage` contents at the end of the session

This captured state is serialized as an `AuthFlow` object and stored in the `DOMInvader` singleton. Replay uses the Chromium context pool and operates headlessly, injecting the captured cookies and replaying recorded steps to obtain a fresh set of tokens.

### DOMInvader: Orchestrator Interface

The `DOMInvader` class is the single point of interaction for `gui_bridge.py`. It handles initialization of the browser pool, exposes the high-level methods used by the REST routes, and stores the current session's saved auth flow.

```python
class DOMInvader:
    async def start()
    async def shutdown()
    async def verify_response(payload, response, timeout_ms) -> VerifyResult
    async def batch_verify_responses(results, timeout_ms) -> List[Dict]
    async def record_auth_flow(login_url, target_ws_url, timeout_s) -> Dict
    async def replay_auth_flow(flow_data=None) -> AuthTokens
    def get_saved_flow() -> Optional[Dict]
    def status() -> Dict
```

The singleton is lazily initialized on the first request to any `/dom/*` route, so there is no startup overhead if the feature is not used.

---

## 3. XSS Verification: Technical Deep Dive <a name="3-xss-verification"></a>

### Why String Matching Fails

A response containing `<script>alert(1)</script>` is not necessarily an exploitable XSS. The content could be:

- Served with a `Content-Security-Policy` header that blocks all inline scripts
- Inside a `<textarea>` or other passive element where the browser does not execute child scripts
- Already HTML-entity encoded before being set as content, e.g., `&lt;script&gt;`
- A reflected value inside a JSON string that is never assigned to a DOM sink

Conversely, some XSS payloads produce no obvious reflection yet still execute. A payload like `" onmouseover="alert(1)" x="` may not appear as a literal script tag in the response but still produces a DOM mutation that an event listener will trigger.

The only reliable method is execution in a real browser runtime. WSHawk's `XSSVerifier` does not attempt to categorize the response by syntax — it simply observes what Chromium does when the content is rendered.

### Instrumented Page Architecture

The test page structure is fixed:

```html
<!DOCTYPE html>
<html>
<head></head>
<body>
    <div id="ws-response">{server_response_content}</div>
    <script data-wshawk="instrumentation">
        /* Override dialog functions, eval, and install MutationObserver */
    </script>
</body>
</html>
```

The server response is inserted directly as the inner HTML of `#ws-response`. This means any HTML in the response is parsed and rendered by Chromium's layout engine exactly as it would be in the target application — including deferred rendering paths, shadow DOM, and imported stylesheets. The instrumentation script uses `data-wshawk` to prevent the MutationObserver from flagging it as an injected element.

### Execution Detection Hierarchy

Results are classified in confidence order:

| Priority | Indicator | Classification |
| :--- | :--- | :--- |
| 1 | Dialog event captured by Playwright | `reflected` |
| 2 | `window.__xss_executed` set by alert/eval override | `dom_based` |
| 3 | Console message containing beacon token | `dom_based` |
| 4 | Script element count in `#ws-response` > 0 | `mutation` |
| 5 | Event handler attribute count in `#ws-response` > 0 | `mutation` |
| None | None of the above | Not executed |

### Supported XSS Technique Classifications

- **reflected**: The payload was reflected into the DOM and a dialog function was called.
- **dom_based**: The page's JavaScript processed the response and executed arbitrary code through a DOM sink.
- **mutation**: The payload caused structural DOM changes that indicate potential execution conditions.
- **stored**: Applicable when the Blaster is used to verify previously stored responses retrieved in a second request.
- **none**: No execution indicators were detected within the timeout window.

---

## 4. Auth Flow Recording and Replay <a name="4-auth-flow"></a>

### Problem Statement: Long-Running Scan Sessions

A typical Payload Blaster session against an authenticated WebSocket endpoint sends between 5,000 and 50,000 payloads depending on the selected category. At a conservative rate of one payload every 300ms, a full XSS wordlist takes approximately 25 minutes. Most session tokens issued by OAuth providers and SSO systems expire between 15 minutes and 2 hours, with 30 minutes being common for SaaS platforms.

When the WebSocket server closes the connection due to a token expiry event, the Blaster receives a `ConnectionClosed` exception. In V3.0.2, this terminates the task and requires the user to re-authenticate manually and restart the scan. Payloads already sent cannot be recovered and any unconfirmed findings may have been missed.

### Recording Procedure

The recording flow is initiated from the Blaster panel using the "Record Auth Flow" button. The user provides the login URL. A visible Chromium window opens and navigates to that URL. The user completes the login using any method the application requires — this includes clicking through OAuth redirects, entering MFA codes, solving CAPTCHAs, or interacting with any JavaScript-driven UI element. The recorder monitors network traffic in the background.

The browser remains open until either the configured timeout expires (default 120 seconds) or the user closes it. On close, the recorder reads the final cookie state, localStorage contents, and any tokens captured from network responses during the session.

### Token Capture Logic

The recorder hooks the Playwright `response` event for every network request made during the recording window. For each response:

1. `Set-Cookie` response headers are parsed and stored individually.
2. JSON response bodies are inspected for known token key patterns.
3. `Authorization` headers on outgoing requests are captured.

The order of priority for authentication when replaying: explicit `Authorization` header, then `access_token` or equivalent from a JSON response, then cookies.

### Headless Replay Mechanics

Replay uses a context from the BrowserPool. The captured cookies are injected using `context.add_cookies()`. localStorage is not directly injectable via Playwright's context API in all configurations, so localStorage-stored tokens are extracted separately and converted to `Authorization` headers for use in the WebSocket connection.

The replay result is an `AuthTokens` object containing:

```python
class AuthTokens:
    cookies: Dict[str, str]
    headers: Dict[str, str]   # Ready for use as WebSocket extra_headers
    session_token: str
    valid: bool
```

The `headers` dictionary is what the Blaster passes to `websockets.connect()` as `extra_headers`. This handles both cookie-based and bearer-token-based WebSocket authentication.

### Auto-Reconnect Integration with Blaster

When the Blaster's inner WebSocket connection raises a `ConnectionClosed` exception during payload transmission and an auth flow has been recorded, the Blaster:

1. Steps the payload index back by one so the interrupted payload is retried.
2. Emits a `blaster_result` info event to the frontend indicating session expiry and replay attempt number.
3. Calls `replay_auth_flow()` to obtain fresh headers.
4. Waits 1 second to allow the server to close the expired session.
5. Opens a new WebSocket connection using the refreshed headers.
6. Continues from the same position in the payload list.

This process repeats up to 3 times before the Blaster terminates with a fatal connection error.

---

## 5. Payload Blaster: V3.0.3 Updates <a name="5-blaster"></a>

### New Parameters: `dom_verify` and `auth_flow`

The `POST /blaster/start` endpoint now accepts two additional fields:

```json
{
  "url": "ws://target.com/socket",
  "payloads": ["<script>alert(1)</script>", "..."],
  "template": "",
  "spe": false,
  "auth_payload": "",
  "dom_verify": true,
  "auth_flow": { ... }
}
```

`dom_verify` is a boolean. When true, the DOM Invader browser pool is initialized on the first request (if not already running) and each successful WebSocket response is passed through the `XSSVerifier` before its result row is emitted.

`auth_flow` is the serialized `AuthFlow` dictionary returned by the `/dom/auth/record` endpoint. Passing it here enables the auto-reconnect logic described in Section 4.

### DOM Verified Results Column

The Blaster results table now includes a sixth column: DOM Verified. When `dom_verify` is disabled, the cell shows a neutral dash. When `dom_verify` is active, each row shows one of three states:

- **Verifying...** — amber badge, shown while the headless check is pending.
- **CONFIRMED XSS** — pulsing red badge with tooltip showing the evidence string (e.g., "Dialog triggered: 1").
- **Unverified** — muted badge, shown when no execution occurred within the timeout.

Hovering any badge displays the `dom_evidence` string from the backend in the title attribute.

### Session Expiry Handling and Reconnect Logic

The Blaster task now runs inside a retry loop rather than a single `async with websockets.connect()` block. This structural change is required to support reconnection. The payload list is consumed by index rather than by iteration, allowing the index to be rewound on a connection failure.

The session expiry event appears in the Blaster results table as a row with payload value `SESSION_EXPIRED`, status `info`, and a response message indicating the replay attempt number.

### Rate Behaviour Changes

The inter-payload sleep was reduced from 500ms to 300ms in this release. Users running against rate-limited targets should note this change and adjust by increasing the sleep at the application level if needed. With DOM verification enabled, the effective rate will be slower due to the verification overhead (typically 2.5 to 4 seconds per payload depending on page complexity).

---

## 6. AI Exploit Engine <a name="6-ai-exploit-engine"></a>

### Architecture

The AI Exploit Engine (`wshawk/ai_exploit_engine.py`) is a standalone module that accepts a selected text value from the ReqForge editor, inspects its syntactic context, builds a context-aware prompt, and returns a list of targeted payloads. It is intentionally isolated from the Scanner and Blaster to avoid coupling the exploration surface to the AI dependency.

The engine is invoked via the `POST /ai/context-exploit` route in `gui_bridge.py`. The route handles request parsing and AI configuration loading; it delegates all domain logic to the engine.

### Context Detection: JSON, XML, URL, Raw

The engine examines the full request body to determine what format the selected value appears in:

- **JSON context**: The selected text is a value within a JSON object. The engine encodes payloads as valid JSON strings and returns a blaster template with the parameter replaced by the `§inject§` marker.
- **XML context**: The selected text appears within an XML element. Payloads are CDATA-wrapped where necessary.
- **URL context**: The selected text is a URL query parameter value. Payloads are URL-encoded.
- **Raw context**: No structural format is detected. Payloads are sent as-is.

The context detection uses a combination of JSON parsing, XML root element detection, and URL parameter regex. The detected context influences both the payload generation prompt sent to the AI model and the encoding applied to the returned payloads.

### AI Provider Configuration

The engine reads its configuration from the `ai:` section of `wshawk.yaml`, populated via the Settings modal:

```yaml
ai:
  provider: ollama
  model: llama3.1
  base_url: http://localhost:11434
  api_key: ""
```

Supported providers are `ollama` (local LLM via HTTP) and `openai` (OpenAI API or compatible endpoints). The provider selection determines the request format sent by the `AIEngine` class.

### Fallback Static Payload System

When no AI model is configured, the engine falls back to a curated static payload set for each vulnerability type. The fallback covers XSS (reflected, DOM, attribute, event handler), SQLi (error-based, boolean-blind, time-based), SSTI (Jinja2, FreeMarker, Twig), XXE, and SSRF. Fallback payloads are context-encoded in the same way as AI-generated payloads, so the user experience is identical regardless of AI availability.

### Blaster Template Auto-Population

When the route returns successfully, the frontend automatically navigates to the Blaster tab and populates:
- The template field with the full request body, with the selected parameter replaced by `§inject§`.
- The payloads field with the returned payload list.
- The payload count display.

No manual copy-paste is required between ReqForge and the Blaster.

---

## 7. REST API: New V3.0.3 Endpoints <a name="7-api"></a>

All DOM Invader routes are served by the same `gui_bridge.py` FastAPI process on port 8080.

### GET /dom/status

Returns the current status of the DOM Invader engine.

**Response:**
```json
{
  "status": "success",
  "playwright_installed": true,
  "browser_running": true,
  "contexts_available": 3,
  "contexts_in_use": 1,
  "auth_flow_saved": false
}
```

`playwright_installed` reflects whether the `playwright` package is importable. `browser_running` indicates whether the `BrowserPool.start()` has been called. If `playwright_installed` is false, all other DOM endpoints will return an error with `msg: "Playwright not installed"`.

### POST /dom/verify

Verifies a single WebSocket payload/response pair in a headless browser.

**Request:**
```json
{
  "payload": "<script>alert(1)</script>",
  "response": "<html>...<script>alert(1)</script>...</html>",
  "timeout_ms": 3000
}
```

**Response:**
```json
{
  "status": "success",
  "executed": true,
  "evidence": "Dialog triggered: 1",
  "technique": "reflected",
  "alert_message": "1",
  "dom_mutations": 1,
  "injected_scripts": 1,
  "injected_handlers": 0,
  "console_messages": [],
  "elapsed_ms": 1243.7
}
```

### POST /dom/verify/batch

Verifies multiple results concurrently, up to 3 at a time (matching the pool size minus one reserved for auth flow operations).

**Request:**
```json
{
  "results": [
    { "payload": "...", "response": "..." },
    { "payload": "...", "response": "..." }
  ],
  "timeout_ms": 3000
}
```

**Response:**
```json
{
  "status": "success",
  "results": [
    {
      "payload": "...",
      "response": "...",
      "dom_verified": true,
      "dom_evidence": "Dialog triggered: 1",
      "dom_technique": "reflected",
      "dom_elapsed_ms": 1102.4
    }
  ]
}
```

### POST /dom/auth/record

Starts an auth flow recording session. This call opens a visible Chromium window and **does not return** until the timeout expires or the browser window is closed. The client should treat this as a long-polling call and display appropriate UI feedback.

**Request:**
```json
{
  "login_url": "https://app.example.com/login",
  "target_ws_url": "wss://app.example.com/socket",
  "timeout_s": 120
}
```

**Response (after browser closes or timeout):**
```json
{
  "status": "success",
  "flow": {
    "name": "auth_1740856800",
    "login_url": "https://app.example.com/login",
    "target_ws_url": "wss://app.example.com/socket",
    "cookies": [ { "name": "session", "value": "...", "domain": "...", "path": "/" } ],
    "extracted_tokens": { "access_token": "eyJ..." },
    "ws_headers": { "Authorization": "Bearer eyJ..." },
    "steps": [],
    "recorded_at": 1740856920.4
  }
}
```

### POST /dom/auth/replay

Replays the saved auth flow (or a provided flow) to obtain fresh tokens.

**Request:**
```json
{
  "flow": { ... }
}
```

The `flow` field is optional. If omitted, the engine replays the flow saved by the most recent `/dom/auth/record` call.

**Response:**
```json
{
  "status": "success",
  "valid": true,
  "cookies": { "session": "abc123" },
  "headers": { "Cookie": "session=abc123", "Authorization": "Bearer eyJ..." },
  "session_token": "eyJ..."
}
```

---

## 8. Frontend Changes: Blaster Panel <a name="8-frontend"></a>

### DOM Invader Control Block

A new control section appears below the "COMMENCE FUZZING" button in the Blaster configuration panel. It contains:
- A section label ("DOM Invader") and a status pill on the right.
- A checkbox labeled "Verify XSS execution in headless Chromium (eliminates false positives)".
- Two buttons side-by-side: "Record Auth Flow" and (when a flow is saved) "Auth Saved (N cookies, N tokens)".
- A status line below the buttons showing recording progress or capture summary.

The control block is always visible regardless of Playwright availability. If Playwright is not installed, the status pill shows "Not Installed" in red with a tooltip showing the installation command. The checkbox and record button remain functional; clicking them produces a clear error from the backend rather than a silent failure.

### Status Pill Behaviour

The `DOMInvaderUI` JavaScript module calls `GET /dom/status` once when the module initializes and again each time the Blaster tab is opened via the navigation bar. The pill updates without page reload.

| State | Class | Label |
| :--- | :--- | :--- |
| Playwright installed, browser running | `dom-status-available` | Playwright Ready |
| Playwright not installed | `dom-status-unavailable` | Not Installed |
| Backend not reachable | `dom-status-unknown` | Offline |
| First load, status check pending | `dom-status-unknown` | Checking... |

### Record Auth Flow Button

Clicking "Record Auth Flow" opens a `prompt()` dialog requesting the login URL. If the user cancels or provides a non-HTTP URL, the action is aborted silently. A valid URL triggers a `POST /dom/auth/record` call.

During the recording session (which blocks on the backend for up to 120 seconds), the button shows "Recording..." in a disabled state and the status line reads "Visible browser opened — complete your login. Auto-closes after 2 minutes."

On successful return, the button reverts to "Re-Record Auth" and the secondary button appears with the capture summary. The captured flow is stored in `window._domInvaderAuthFlow` and passed automatically to `/blaster/start` when fuzzing begins.

Clicking the secondary "Auth Saved" button prompts the user to confirm flow discard, then clears `window._domInvaderAuthFlow` and hides the button.

### DOM Verified Column in Results Table

The results table header row now contains six columns: Payload, Status, Length, DOM Verified, Diff, Response Snippet. The ordering places DOM Verified before Diff to give the verification result visual prominence.

Each row's DOM Verified cell is populated by `addBlasterResult()` on creation and updated by `updateBlasterResult()` when the backend emits the `blaster_result` Socket.IO event with `dom_verified` data. If `dom_verify` was not enabled for the current session, the cell shows a dash with no badge styling.

---

## 9. PyInstaller Spec Updates <a name="9-pyinstaller"></a>

### New Hidden Imports

Three new WSHawk modules must be included in the PyInstaller bundle:

```python
'wshawk.ai_exploit_engine',
'wshawk.dom_invader',
'wshawk.headless_xss_verifier',
```

`headless_xss_verifier` is included for backward compatibility with any external scripts that import it directly. It is not called by the current codebase but remains a public module.

### Playwright Handling

Previous versions of the spec explicitly excluded Playwright from the bundle:

```python
excludes=['playwright'],
```

This caused the bundled binary to fail when users had Playwright installed on their system, because the import-time check `HAS_PLAYWRIGHT = True` would succeed in development but fail in the binary. The exclusion has been removed and replaced with explicit `hiddenimports` entries:

```python
'playwright',
'playwright.async_api',
'playwright._impl._api_types',
'playwright._impl._browser',
'playwright._impl._browser_context',
'playwright._impl._page',
'playwright._impl._network',
'playwright._impl._dialog',
'playwright.sync_api',
```

PyInstaller uses static analysis to discover imports. The `try/except ImportError` pattern used in `dom_invader.py` is not followed by static analysis, so Playwright's submodules would never be discovered automatically. The explicit list ensures they are bundled when Playwright is installed in the build environment.

If Playwright is not installed in the build environment, PyInstaller will silently skip those entries. The resulting binary will have `HAS_PLAYWRIGHT = False` at runtime on any system, which is the correct graceful degradation behaviour.

---

## 10. Deployment and Installation <a name="10-deployment"></a>

### Playwright System Requirements

Playwright's Chromium build requires a set of shared libraries that may not be present on minimal server installations. On Debian/Ubuntu-based systems:

```bash
apt-get install -y libnss3 libatk1.0-0 libatk-bridge2.0-0 \
    libcups2 libgtk-3-0 libasound2 libxss1 libgbm1
```

On Arch Linux, these are pulled in automatically by the `wshawk` PKGBUILD via the `nss`, `alsa-lib`, and `gtk3` dependencies.

Auth flow recording requires a display server because it opens a visible browser window (`headless=False`). On headless CI servers or SSH sessions without X11 forwarding, the recording feature is unavailable. Verification (`headless=True`) works without a display.

### Sandboxed Chromium Flags

The BrowserPool launches Chromium with the following flags in all environments:

```python
args=[
    "--no-sandbox",
    "--disable-setuid-sandbox",
    "--disable-dev-shm-usage",
    "--disable-gpu",
]
```

`--no-sandbox` is required when running as root (common in Docker containers). The sandbox restriction is not a meaningful security boundary in this context because WSHawk is a security testing tool running in a controlled environment against targets the user has permission to test, not a browser handling untrusted user traffic.

### CI/CD Considerations

DOM verification is compatible with CI environments that provide a Chromium binary. GitHub Actions runners with `ubuntu-latest` include the system libraries required. Install Playwright's browser after the Python dependencies step:

```bash
pip install playwright
playwright install chromium --with-deps
```

Auth flow recording cannot be used in CI. Skip it by omitting `auth_flow` from the `/blaster/start` request body.

---

## 11. Upgrade Path from V3.0.2 <a name="11-upgrade"></a>

### Breaking Changes

There are no breaking changes between V3.0.2 and V3.0.3. Existing configuration files, API calls, and workflows remain valid. The Blaster results table has a new column, which affects any code that parses the HTML table output directly by column index, but this is not a supported external interface.

The `run_blaster_task` function signature has changed with two new optional keyword arguments (`dom_verify=False`, `auth_flow=None`). Any external code calling this function directly should verify it passes arguments by keyword name rather than position.

### New Optional Dependencies

```
playwright>=1.40.0
```

This dependency was already listed in `pyproject.toml` from the original V3.0.0 release. No new packages are required. Users who had previously skipped the Playwright installation step can install it now:

```bash
pip install playwright
playwright install chromium
```

---

## 12. Troubleshooting <a name="12-troubleshooting"></a>

**Q: The DOM Invader status pill shows "Not Installed" but I have playwright installed.**

A: Confirm that Playwright is installed in the same Python environment as the WSHawk backend. If WSHawk was installed via the packaged binary (`wshawk-bridge`), Playwright must be available to that binary's bundled Python runtime. Rebuild the binary with Playwright installed in the build environment.

**Q: Auth replay returns `valid: false` with empty headers.**

A: The replay mechanism injects the cookies captured during recording and replays the recorded navigation steps. If the application's session architecture requires re-completing JavaScript-driven login steps (not just cookie injection), the replay may not produce a valid session. In this case, use the static `auth_payload` field in the Blaster which sends a raw WebSocket authentication frame after connection, rather than HTTP-level auth.

**Q: DOM verification always times out on responses that are valid HTML.**

A: The default timeout is 3000ms. For pages with heavy JavaScript initialization (e.g., React or Angular applications that take time to mount), increase `timeout_ms` in the `/dom/verify` request body. Also verify that the response content being passed is the raw HTML/text from the WebSocket response, not a JSON-encoded string wrapper around it.

**Q: The visible browser for auth recording closes immediately without allowing login.**

A: The `timeout_s` parameter controls how long the visible browser stays open. The default is 120 seconds. If you need more time for a complex SSO flow (particularly those with multiple redirects and email verification steps), pass a higher `timeout_s` value in the `/dom/auth/record` request.

**Q: The Blaster reconnect loop fires even when the connection is closed intentionally.**

A: The reconnect logic triggers on any `ConnectionClosed` exception from the `websocket.recv()` call. If you call the `/blaster/stop` endpoint, the reconnect will still attempt because the connection closure comes from the server side. The three-attempt limit prevents it from looping indefinitely, and the cancellation path is triggered by the asyncio task's `CancelledError` which takes priority.

---

## 13. Glossary <a name="13-glossary"></a>

- **BrowserPool**: A managed collection of pre-warmed Chromium `BrowserContext` objects used to avoid cold-start overhead during repeated XSS verification requests.
- **AuthFlow**: A serialized record of a completed login session, containing cookies, tokens, and request headers required to re-establish an authenticated WebSocket connection.
- **AuthTokens**: The output of an auth flow replay operation, containing the HTTP headers ready for use as WebSocket `extra_headers`.
- **DOM Invader**: The collective name for the `dom_invader.py` engine, its three component classes, and the associated REST routes and frontend controls.
- **CONFIRMED XSS**: A finding classification assigned when the XSSVerifier observes actual JavaScript execution in a headless Chromium instance rendering the server's response.
- **Unverified**: A finding classification assigned when a response contains XSS-like content but no execution was observed within the verification timeout.
- **HAS_PLAYWRIGHT**: A module-level boolean set at import time in `dom_invader.py`, indicating whether the Playwright package is available in the current runtime environment.
- **MutationObserver**: A browser API used to monitor the DOM for structural changes. WSHawk's instrumented test page uses it to detect injected script elements and event handler attributes.
- **Session Expiry Auto-Reconnect**: The Blaster's mechanism for detecting a `ConnectionClosed` exception mid-fuzz, replaying a recorded auth flow, and resuming the payload sequence from the interrupted position.
- **context-exploit**: The `/ai/context-exploit` route and associated frontend context menu that generates targeted payloads based on the syntactic position of a selected value in the ReqForge editor.
- **SPE**: Smart Payload Evolution. The genetic mutation engine that adapts payloads based on server response signals. Present since V2.0.7.
- **OAST**: Out-of-Band Application Security Testing. Blind vulnerability detection via DNS or HTTP callbacks to a controlled external server.

---

## 14. Support <a name="14-support"></a>

WSHawk V3.0.3 is an open-source project maintained by Regaan.

- **Developer**: Regaan (@noobforanonymous)
- **Organization**: Rot Hackers
- **GitHub**: https://github.com/noobforanonymous/wshawk
- **Issues**: https://github.com/noobforanonymous/wshawk/issues
- **Email**: support@rothackers.com

Bug reports specific to the DOM Invader should include: operating system, Playwright version (`playwright --version`), Chromium version (`playwright show-trace` or Playwright's built-in version output), and the response body that failed to trigger execution when a manual browser test confirmed it should.

---
**WSHawk V3.0.3** - Built by Regaan for the global security research community.
